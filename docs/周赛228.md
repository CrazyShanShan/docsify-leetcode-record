# 周赛228 2021年，2月14号。

今天的4题对于大佬来说比较简单，对我来说还是太难了， 做了第一题和第二题。下面对四题进行整理。哭了，今天的剑指offer的一个题还没做。



## 题目1:  easy  [5676. 生成交替二进制字符串的最少操作数](https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/)

给你一个仅由字符'0'和'1'组成的字符串s。一步操作中，你可以将任一'0'变成'1'，或者将'1'变成'0'。

**交替字符串**定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串“010”是交替字符串，而字符串“0100”不是。

返回 s 变成**交替字符串****所需要 **最少**操作数。

示例1:

输入： s="0100"

输出： 1

解释：如果将最后一个字符变成'1'，s就变成“0101”,即符合交替字符串定义。



示例2:

输入：s=“10”

输出：0

解释：s已经是交替字符串。



示例3:

输入: s = "1111"

输出：2

解释：需要2步操作得到“0101” 或“1010”。



提示：

- 1<= s.length <= 10^4
- s[i] 是'0' 或 ‘1’



题解及分析：

刚开始看这个题的时候，感觉需要用dp，然后就去做t2了，最后又看了眼题是个easy题，就没有多想。

开始考虑第一个字符是 0 ，那么最终的交替字符串就为 0101010101～

第一个字符是1，那么最终的交替字符串就为10101010101010～

然后将这两种情况代入到s，计算s需要变化的次数，返回两个次数的最小值即可。

```java

class Solution {
    public int minOperations(String s) {
        char zero = '0';
        char one = '1';
        int ans1 = 0;
        int ans2 = 0;
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (i % 2 == 0) {
                if (ch == zero) ans1++;
                if (ch == one) ans2++;
            } else {
                if (ch == one) ans1++;  
                if (ch == zero) ans2++;
            }
        }
        return Math.min(ans1,ans2);
    }
}
```

之后在看看 排名前面的大佬的题解吧～



