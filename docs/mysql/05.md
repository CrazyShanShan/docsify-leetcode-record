# 05 | 查询性能优化（第六章）

195-258	

前面的章节我们介绍了如何设计最优的库表结构、如何建立最好的索引，这些对于高性能来说是必不可少的。但这些还不够-还需要合理的设计查询。如果查询写得很糟糕，即使库表结构再合理、索引再合适，也无法实现高性能。

查询优化、索引优化、库表结构优化需要齐头并进，一个不落。在获得编写MySQL查询的经验都同时，也将学习到如何为高效的查询设计表和索引。同样的 ，也可以学习到在优化表结构时也会影响到哪些类型的查询。这个过程需要时间，所以建议大家在学习后面章节的时候多回头看看这三章的内部。

本章将从查询设计的一些基本原则开始-这也是在发现查询效率不高的时候首先需要考虑的因素。然后会介绍一些更深的查询优化的技巧，并会介绍一些MySQl优化器内部的机制。我们将展示MySQl是如何执行查询的，你也将学会如何去改变一个查询的执行计划。最后，我们要看一下MySQL优化器在哪些方面做得还不够，并探索查询优化的模式，以帮助MySQL更有效地执行查询。

本章的目标是帮助大家更深刻地理解MySQL如何真正地执行查询，并明白高效和低效的原因何在，这样才能充分发挥MySQL的优势，并避开它的弱点。

## 6.1为什么查询速度会慢

在尝试编写快速的查询之前，需要清楚一点，真正重要是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。

> 有时候你kennel还需要修改一些查询，减少这些查询对系统中运行得其他查询的影响。这种情况下，你是在减少一个查询的资源消耗，这我们在第3章已经讨论过。

MySQL在执行查询的时候有哪些子任务，哪些子任务运行的速度很慢？这里很难给出完整的列表，但如果按照第3章介绍的方法对查询进行剖析，就能看到查询所执行的子任务。通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生产执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。

在完成这些任务的时候，查询需要在不同的地方话费时间，包括网络，CPu计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据等调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。

在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是减少和消除这些操作所话费的时间。

再次申明一点，对于一个查询的全部生命周期，上面列的并不完整。这里我们只是想说明：了解查询的生命周期、清楚查询的时间消耗情况对于优化查询有很大的意义。有了这些概念，我们再一起来看看如何优化查询。

## 6.2 慢查询基础：优化数据访问

查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤分析总是很有效：

1. 确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。
2. 确认MySQL服务器层是否在分析大量超过需要的数据行。

### 6.2.1 是否向数据库请求了不需要的数据

有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。

这里有一些典型案例：

**查询不需要的记录：**

​	一个常见的错误是常常会误以为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。我们经常会看到一些了解其他数据库系统的人会设计出这类应用程序。这些开发者习惯使用这样的技术，先使用SELECT语句查询大量的结果，然后获取前面的N行后关闭结果集（例如在新闻网站中取出100条记录，但是只是在页面上显示前面10条）。他们认为MySQL会执行查询，并返回他们需要的10条数据，然后停止查询。实际情况是MySQL会查询出全部的结果集，客户端的应用程序会接受全部的结果集数据，然后抛弃其中大部分数据。最简单有效的解决方法就是在这样的查询后面加上LIMIT。

**多表关联时返回全部列**

​	如果你想查询所有电影Academy Dinsaur中出现的演员，千万不要按下面的写法编写查询：

```mysql
select * from sakila.actor
inner join sakila.fiml_actor USING(actor_id)
inner join sakila.film Using(film_id)
where sakila.film.title = "Academy Dinosaur";
```

​	这将返回这三个表的全部数据列。正确的方式应该是像下面这样只取需要的列：

```mysql
select sakila.actor.* from sakila.actor...;
```

> 在oracle的连接（join)中使用using关键字
>
> schema中有一个表是sales，有一个表是costs，这两个表中都分别有两个字段为pro_id和time_id
>
> 1. select * from sales natural join costs;
> 2. select * from sales join costs on sales.prod_id = costs.prod_id and sales.time_id = costs.time_id
> 3. select * from sales, costs where sales.pro_id = cost.prod_id and sales.time_id = costs.time_id
>
> 这三者得到的结果是一样的。
>
> 如果我们使用自然连接，就没有机会控制连接条件，oracle自作主张的将两个相同数据类型和名称的字段自然地连接在一起了。
>
> 下面我们使用using关键字。
>
> select * from sales join costs using(prod_id)
>
> 这样就迫使oracle使用using指出的字段来做连接，而不是natural join连接中默认的两个。

**总是取出全部列**

​	每次看到select * 的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能不是必须的。取出全部列，会让优化器无法完成**索引覆盖扫描**这类优化，还会为服务器带来额外的IO、内存和CPU的消耗。因此，一些DBA是严格禁止SELECT*的写法的，这样做有时候还能避免某些列被修改带来的问题。

​	当然，查询返回超过需要的数据也不总是坏事。在我们研究过的许多案例中，人们会告诉我们说这种有点浪费数据库资源的方式可以简化开发，因为能提高相同代码的复用性，如果清楚这样做的性能影响，那么这种做法也是值得考虑的。如果应用程序使用了某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其好处，但不要忘记这样做的代价是什么。获取并缓存所有列的查询，相比多个独立的只获取部分列的查询可能就更有好处。

**重复查询相同的数据**

​	如果你不小心，很容易出现这样的错误---不断地重复执行相同的查询，然后每次都返回完全相同的数据。例如，在用户评论的地方需要查询用户头像的URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。

### 6.2.2 MySQL是否扫描额外的记录

在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：

- 响应时间
- 扫描行数
- 返回行数

没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQl在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQl的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。

**响应时间**

要记住，响应时间只是一个表面上的值。这样说可能看起来和前面关于响应时间的说法有矛盾？其实并不矛盾，响应时间仍然是最重要的指标，这有一点复杂，后面慢慢道来。

响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间--可能是等IO操作完成，也可能是等待行锁等等。遗憾的是，我们无法把响应时间细分到上面这些部分，除非有什么办法能够逐个测量上面的这些消耗，不过很难做到。一般最常见和重要的是等待IO和锁等待，但实际情况更佳复杂。

所以在不同类型的应用压力下，响应时间并没有一致的规律或者公式。诸如存储引擎的锁、高并发资源竞争、硬件响应等诸多因素都会影响到响应时间。所以，响应时间即可能是一个问题都结果也可可能是一个问题都原因，不同案例情况不同，除非能够使用第3章介绍的”单个查询问题还是服务器问题“一节介绍的技术来确定到底是因还是过。

当你看到一个查询的响应时间的时候，首先需要问问自己，这个响应时间是否是一个合理的值。实际上可以使用“快速上限估计”法来估算查询的响应时间。

概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以具体硬件条件下一次IO的消耗时间。最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。

**扫描的行数和返回的行数**

分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上说明该查询找到需要的数据的效率高不高。

对于找出哪些“糟糕”的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。

理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种好事不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比例通常很小，一般在1:1到10:1之间，不过有时候这个值也可能非常大。

**扫描的行数和访问类型**

在评估查询开销的时候，需要考虑一下从表中找到某一行的数据成本。MySQL有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能访问一行结果，也有些访问方式可能无须扫描就能访问就能返回结果。

在expalin语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这样，速度是从慢到快到，扫描到行数也是从小到大。你不需要记住这些访问类型，但需要明白扫描表、扫描索引、范围访问和单值访问的概念。

如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引，这也是我们前一章讨论过的问题。现在应该明白为神马索引对于查询优化如此重要的。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。

例如，我们看看示例数据库Sakila中的一个查询案例：

```mysql
select * from sakila.film_actor where film_id = 1;
```

这个查询将返回10行数据，从EXPLAIN的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询：

<img src="images/image-20210318151923992.png" alt="image-20210318151923992" style="zoom:50%;" />

explain的结果也显示了MySQL预估需要访问10行数据。换句话说，查询优化器认为这种访问类型可以高效地完成查询。如果没有合适的索引会怎么样呢？MySQL就不得不使用一种更糟糕的访问类型，下面我们来看看如果我们删除对应的索引再来运行这个查询：

<img src="images/image-20210318152216309.png" alt="image-20210318152216309" style="zoom:50%;" />

正如我们预测的，访问类型变成了一个全表扫描ALL，现在MySQL预估需要扫描5073条记录来完成这个查询。这里的“Using where”表示MySQL将通过where条件来筛选存储引擎返回的记录。

一般MySQL能够使用如下三种方式应用where条件，从好到坏依次为：

- 在索引中使用where 条件来过滤不匹配的记录。这是在存储引擎完成的。
- 使用索引覆盖扫描（在Extra 列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须在回表查询记录的。
- 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要从数据表读出记录然后过滤。

上面这个例子说明了好的索引多么重要。好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。

例如下面使用聚合函数count()的查询：

```mysql
select acotr_id, count(*) from sakila.film_actor group by actor_id;
```

这个查询需要读取几千行数据，但是仅返回200行结果。没有什么索引能够让这样的查询减少需要扫描的行数。

> ​	更多内容请参考后面“优化count()查询”。

不幸的是，MySQl不会告诉我们生成结果实际上需要扫描多少行数据，而只会告诉我们生成结果时一共扫描了多少行数据。

> 例如关联查询结果返回的一条记录通常是由多条记录组成。

扫描的行数中的大部分都很可能是被where条件过滤掉的，对最终的结果集并没有贡献。在上面的例子中，我们删除索引后，看到MySQL需要扫描所有记录然后根据where 条件过滤，最终只返回10行结果。理解一个查询需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。

如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：

- 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。
- 改变库表结构。例如使用单独的汇总表（第4章中讨论的方法）。
- 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询（这是本章后续需要讨论的问题）。

## 6.3 重构查询的方式

在优化有问题的查询时，目标应该是找到一个更有的方法获得实际需要的结果————而不是一定总是需要从MySQL获取一模一样的结果集。有时候，可以将查询转换一种写法让其返回一样的结果，但是性能更好。但也可以通过修改应用代码，用另一种方式完成查询，最终达到一样的目的。这一届我们将介绍如何通过这种方式来重构查询，并展示何时需要使用这样的技巧。

### 6.3.1 一个复杂查询还是多个简单查询

设计查询的时候一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。在传统实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。

但是这样的想法对于MySQL并不适用， MYSQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟。在某些版本的MySQL上，即使在一个通用服务器上，也能够运行每秒超过10万的查询，即使是一个千兆网卡也能轻松满足每秒超过2000次的查询。所以运行多个小查询现在已经不是大问题了。

MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MYSQL相应数据给客户端就慢得多了。在其他条件都相同的时候，使用尽可能少的查询当然是好的。但是有时候，将一个大查询分解为多个小查询是很有必要的。别害怕这样做，好好衡量一下这样做是不是会减少工作量。稍后我们将通过本章的一个示例来展示这个技巧的优势。

不过，在应用设计的时候，如果一个查询能够胜任时还写成多个独立查询是不明智的。例如，我们看到有些应用对一个数据表做10次独立的查询来返回10行数据，每个查询返回一条结果，查询10次！

### 6.3.2 切分查询

有时候对于一个大查询我们需要“分而治之”，将大查询分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。

删除旧的数据就是一个很好的例子。定期地清楚大量数据时，如果用一个大大语句一次性完成的话，则可能需要一次锁住很多数据、占用整个事物日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大大DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。例如，我们需要每个月运行一次下面的查询：

```mysql
delete from messages
where created < DATA_SUB(NOW(), INTERVAL 3MONTH);
```

那么可以用类似下面的办法来完成同样的工作：

```mysql
rows_affected = 0
do {
	rows_affected = do_query(
		"delete from messages where created < DATE_SUB(NOW(), INTERVAL 3MONTH)
			limit 10000
		"
	)
} while rows_affected > 0
```

一次删除一万行数据一般来说是一个比较高效而且对服务器影响也较小的做法（如果是事务型引擎，很多时候小事物能够更高效）。同时，需要注意的是，如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大较少删除时的特有时间。

### 6.3.3 分解关联查询

很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。例如，下面这个查询：

```mysql
select * from tag
	join tag_post on tag_post.tag_id = tag.id
	join post on tag_post.post_id = post.id
where tag.tag = 'mysql';
```

可以分解成下面这些查询来代替：

```mysql
select * from tag where tag = 'mysql';
select * from tag_post where tag_id = 1234;
select * from post where post.id in (123,456,567,9098,8904);
```

到底为什么要这么做？咋一看，这样做并没有什么好处，原本一条查询，这里却变成多条查询，返回的结果又是一模一样的。事实上，用分解关联查询的方式重构查询有如下的优势：

- 让缓存的效率更高。 许多应用程序可以方便地缓存单表查询对应的结果对象。例如，上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123、567、9098的内容，那么第三个查询的IN（） 中就可以少几个ID。另外，对MYSQL的查询缓存来说（Query Cache），如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。
- 将查询分解后，执行单个查询可以减少锁的竞争。
- 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
- 查询本身效率也可能会有所提升。在这个例子中，使用IN（）代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联更高效。我们后续将详细介绍这点。
- 可以减少冗余记录的查询。在应用层做关联，意味着对于某条记录应用只需要查询一次，而在数据库中做关联，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存消耗。
- 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MYSQL的嵌套循环关联。某些场景哈希关联要高很多（本章后续我们将讨论这点）。

在很多场景，通过重构查询将关联放到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询的结果的时候、当可以将数据分布到不同的MySQL服务器上的时候、当能够使用IN（）的方式代替关联查询的时候、当查询中使用同一个数据表的时候。

## 6.4 查询执行的基础

当希望MySQL能够以更高对性能运行查询时，最好的办法就是弄清楚MYSQL是如何优化和执行查询的。一旦理解这一点，很多查询优化工作实际上就是遵循一些原则让优化器能够按预想的合理的方式运行。

换句话说，是时候回头看看我们前面讨论的内容了：MYSQL执行一个查询的过程。根据图6-1，我们可以看到当向MySQL发送以一个请求的时候，MySQL到底做了些什么：

<img src="images/image-20210321101604123.png" alt="image-20210321101604123" style="zoom:50%;" />

1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。
3. 服务器进行SQLK解析、预处理，再由优化器生成对应的执行计划。
4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
5. 将结果返回给客户端。

上面的每一步都比想象的复杂，我们在后续章节中将继续讨论。我们会看到在每一个阶段查询处于何种状态。查询优化器是其中特别复杂也特别难理解的部分。还有很多的例外情况，例如，当查询使用绑定变量后，执行路径会有所不同，我们将在下一章讨论这点。

### 6.4.1 MySQL 客户端/服务器通信协议

一般来说，不需要去理解MySQL通信协议的内部实现细节，只需要大致理解通信协议是如何工作的。MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发送。所以，我们无法也无须将以个消息切成小块独立来发送。

这种协议让MySQL通信简单快速，但是也从很多地方限制了MYSQL。一个明显的限制是，这意味着没法进行流量控制。一旦一端开始发生消息，另一段要接受完整个消息才能是响应它。这就像来回抛球的游戏：在任何时刻，只有一个人能控制球，而且只有控制球的人才能将球抛回去（发送消息）。

客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候，参数max_allowed_packet就特别重要了。一旦客户端发送了请求，它能做的事情就只是等待结果了。

> 如果查询太大，服务器就会拒绝接受更多的数据并抛出相应错误。

相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接受整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这种情况下，客户端若接受完整的结果，然后取前面几条需要的结果，或者接受完几条结果后就“粗暴”地断开连接，都不是好主意。这也是在必要的时候一定要在查询中加上limit限制的原因。

换一种方式解释这种行为：当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是MySQL在向客户端推送数据的过程。客户端不断地接受从服务器推送的数据，客户端也没法让服务器停下来。客户端像是“从消防水管喝水”。

多数连接MySQL的库函数都可以获取全部结果集并缓存到内存里，还可以助逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接受全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放相应的资源。

当使用多数连接mySQL的库函数从mysql获取数据时，其结果看起来都像是从mysql服务器获取数据，而实际上都是从这个库函数的缓存获取数据。多数情况下这没什么问题，但是如果需要一个很大的结果集的时候，这样做并不好，因为库函数会花很多时间和内存来存储所有的结果集。如果能够尽早开始处理这些结果集，就能大大减少内存的消耗，这种情况下可以不使用缓存来记录结果而是直接处理。这样做的缺点是，对于服务器来说，需要查询完成后才能释放资源，所在在和客户端交互的整个过程中，服务器的资源都是被这个查询所占用的。

> 你可以使用SQL_BUFFER_RESULT，后面将再介绍这

我们看看使用PHP的时候是什么情况。首先，下面是我们连接MySQL的通常写法：

```php
<?php 
$link = mysql_connect('localhost','user','password');
$result = mysql_query('select * from huge_table',$link);
while ($row = mysql_fetch_array($result)) {
	//Do  something with result
}
?>
```

这段代码看起来像是只有当你需要的时候，才通过循环从服务器端取出数据。而实际上，在上面的代码中，在调用mysql_query()的时候，php就已经将整个结果集缓存到内存中。下面的while循环只是从这个缓存中逐行取出数据，相反如果使用下面的查询，用mysql_unbuffered_query()代替mysql_query()，php则不会缓存结果：

```php
<?php 
$link = mysql_connect('localhost','user','password');
$result = mysql_unbuffered_query('select * from huge_table',$link);
while ($row = mysql_fetch_array($result)) {
	//Do  something with result
}
?>
```

不同的编程语言处理缓存的方式不同。例如，在perl的DBD： mysql驱动总需要制定C连接库的mysql_use_result属性（默认是mysql_buffer_result）。下面是一个例子：

<img src="images/image-20210321113333126.png" alt="image-20210321113333126" style="zoom:50%;" />

注意到上面的prepare()调用制定了mysql_use_result属性为1，所以应用将直接“使用‘返回的结果集而不会将其缓存。也可以在连接mysql的时候制定这个属性，这会让整个连接都使用不缓存的方式处理结果集：

```perl
my $dbh = DBI->connect('DBI:mysql:;mysql_user_result=1','user','p4ssword')
```

#### **查询状态**

对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态，该状态表示了MySQL当前正在做什么。有很多种方式能查看当前的状态，最简单的是使用**show full processlist**命令（该命令返回结果中的Command列就表示当前的状态）。在一个查询的生命周期中，状态会变化很多次。MySQL官方手册中对这些状态值的含义有最权威的解释，下面将这些状态列出来，并做一个简单的解释。

**Sleep**

​	线程正在等待客户端发送新的请求。

**Query**

​	线程正在执行查询或者正在将结果发送给客户端。

**Locked**

​	在MySQL服务器，该线程正在等待表锁。在存储引擎级别实现的锁，例子如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常出现。

**Analyzing and statistics**

​	线程正在收集存储引擎的统计信息，并声称查询的执行计划。

**Copying to tmp table 【disk】**

​	线程正在执行查询，并且将其结果都复制到一个临时表中，这种状态一般要么是做group by操作，要么是文件排序操作，或者是union操作。如果这个状态后面还有“on disk”标记，那么表示MySQL正在将一个内存临时表放到磁盘上。

**Sorting result**

​	线程正在对结果进行排序。

**Sending data**

​	这表示多种情况：线程可能在多个状态之间传送数据，或者生成结果集，或者在向客户端返回数据。

了解这些状态的基本含义非常有用，这可以让你很快地了解当前“谁正在持球”。在一个繁忙的服务器上，可能会看到大量的不正常的状态，例如statistics正在占用大量的时间。这通常表示，某个地方有异常了，可以通过第3章的一些技巧来诊断到底是哪个环节出现了问题。

### 6.4.2 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即时只有一个字节不同，那也不会匹配缓存结果，这种情况下查询就是进入下一阶段的处理。

> 这里是指Query Cache，Perconaw版本的MySQL中提供了一个新的特性，可以在计算查询语句哈希值时，先将注释移除再算哈希值，这对于不同注释的相同查询可以命中相同的查询的缓存结果。

如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。这仍然是无需解析SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL会跳过其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不会生成执行计划，不会被执行。在第7章中的查询缓存一节中，你将学习到更多细节。

### 6.4.3 查询优化处理

查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再按照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。这里不打算详细介绍MySQL内部实现，而只是选择性地介绍其中几个独立的部分，在实际执行中，这几个部分可能一起执行也可能单独执行。我们的目的是帮助大家理解MySQL如何执行查询，以便写出更优秀的查询。

#### **语法解析器和预处理**

首先，MySQL通过关键字将SQL语句进行解析，并生成一棵对应的“解析树”。MySQL解析器将使用MYSQL语法规则验证和解析查询。例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。

预处理则根据一些MYSQL规则进一步检查解析树是否合法，例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看看他们是否有歧义。

下一步预处理器会验证权限。这通常很快，除非服务器上有非常多的权限配置。

#### **查询优化器**

现在语法树被认为是合法的了，并且由优化器讲其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。

MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种计划时的成本，并选择其中成本最小的一个。最初，成本的最小单位是随机读取一个4K数据页的成本，后来变得更佳复杂，并且引入了一些“因子”来估算某些操作的代价，如当执行一次where条件比较的成本。可以通过查询当前会话的Last_query_cost的值来的值MySQL计算的当前查询的成本。

```mysql
select SQL_NO_CACHE count(*) from sakila.film_actor;
show status like 'Last_query_cost';
```

这个结果表示MySQL的优化器认为大概需要做1040个数据页的随机查找才能完成上面的查询。这是根据一系列的统计信息计算得来的：每个表或者索引的页面个数、索引的基数、索引和数据行的长度、索引分布情况。优化器在评估成本的时候并不考虑任何层面的缓存，它假设读取任何数据都需要一次磁盘I/O。

有很多种原因会导致MySQL优化器选择错误的执行计划，如下所示：

- **统计信息不准确**。MySQL依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息是准确的，有的偏差可能非常大。例如，InnoDb因为其MVCC的架构，并不能维护一个数据表的行数的精确统计信息。
- **执行计划中的成本估算不等同于实际执行的成本**。所以即使统计信息精准，优化器给出的执行计划也可能不是最优的。例如有时候某个执行计划虽然需要读取更多的页面，但是它的成本却更小。因为如果这些页面都是顺序读或者这些页面都已经在内存中的话，那么它的访问成本将很小。MySQL层面并不知道哪些页面在内存中、哪些在磁盘上，所以查询实际执行过程中到底需要多少次物理I/O是无法得知的。
- **MySQL的最优可能和你想的最优不一样。**你可能希望执行时间尽可能的短，但是MySQL只是基于成本模型选择最优的执行计划，而有时候这并不是最快的执行方式。所以，这里我们看到根据执行成本来选择执行计划并不是完美的模型。
- **MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询到速度。**
- **MySQL也并不是任何时候都是基于成本的优化。**有时也会基于一些固定固定规则，例如，如果存在全文搜索的MATHC（）子句，则在存在全文索引的时候就使用全文索引。即使有时候使用别的索引和WHERE条件可以远比这种方式要快，MySQL也仍然会使用对应的全文索引。
- **MySQL不会考虑不受控制的操作的成本，例如执行存储过程或者用户指定一函数的成本。**
- 后面我们还会看到，优化器有时候无法去估算所有可能的执行计划，所以它可能错过实际上最优的执行计划。

MySQL的查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划。优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。静态优化可以直接对解析树进行分析，并完成优化。例如，优化器可以通过一些简单的代数变换将where条件转换成另一种等价形式。静态优化不依赖于特别的数值，如where条件中带入的一些常数等。静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生变化。可以认为这是一种“编译时优化”。

相反，动态优化则和查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对应的数据行数等。这需要在每次的查询的时候都重新评估，可以认为这是“运行时优化”。

在执行语句和存储过程的时候，动态优化和静态优化的区别非常重要。MYSQL对查询的静态优化只需要做一次，但对查询的动态优化则在每次执行都需要重新评估。有时候甚至在查询的执行过程中也会重新优化。

下面是一些MySQL能够处理的优化类型：

**重新定义关联表的顺序**

​	数据表的关联并不总是按照在查询中指定的顺序进行。决定关联的顺序是优化器很重要的一部分，本章后面将深入介绍这一点。

**将外连接转化成内连接**

​	并不是所有的OUTER JOIN语句都必须以外连接的方式执行。诸多因素，例如WHERE条件、库表结构都可能会让外连接等价于一个内连接。MySQL能够识别这点并重写查询，让其可以调整关联顺序。

**使用等价变换规则**

​	MySQL可以使用一些等价变换来简化并规范表达式。它可以合并和减少一些比较，还可以移除一些恒成立和一些我恒不成立的判断。例如，（5=5AND a>5）将

被改写成为a>5。类似的，如果有（a<b and b=c） and a=5,则会被改写 b >5 and b =c and a = 5。这些规则对于我们编写条件语句很有用，我们将在本章后续继续讨论。

**优化COUNT（）、MIN（）和MAX（）**

​	索引和列是否可以为空通常可以帮助MYSQL优化这类表达式。例如，要找到某一列的最小值，只需要查询对应B-Tree索引最左端的记录，MySQL可以直接获取索引的第一行记录。在优化器生产执行计划的时候就可以利用这一点，在B-Tree索引中，优化器会急哦昂这个表达式作为要i个常数对待。类似的，如果要查找一个最大值，也只需读取B-Tree索引的最后一条记录。如果MySQL使用了这种类型的优化，那么在EXPLAIN中就可以看到“Select ables optimized away”。从字面意思可以看出，它表明优化器已经从执行计划中移除了该表，并以一个常数取而代之。

​	类似的，没有任何WHERE条件的的COUNT（*）查询通常也可以使用存储引擎提供的一些优化（例如，MyISAM维护了一个变量来存放数据表的行数）。

**预估并转化为常数表达式**

​	当MySQL检测到以个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。例如，一个用户自定义变量在查询中没有没有发生变化时就可以转换为一个常数。数学表达式是另一种典型的例子。

​	让人惊讶的是，在优化阶段，有时候甚至一个查询也能够转化为一个常数。一个例子是在索引列上执行MIN（）函数。甚至是主键或者唯一键查找语句也可以转化为常数表达式。如果WHERE子句中使用了该类索引的常数条件，MYSQL可以在查询开始阶段就先找到这些值。下面是一个例子：

```mysql
explain select film.film_id,film_actor.actor_id 
from sakila.film
	inner join sakila.film_actor using(film_id)
where film.film_id = 1
```

<img src="images/image-20210322111159647.png" alt="image-20210322111159647" style="zoom:50%;" />

​	MySQL分两步来执行这个查询，也就是上面的执行计划的两行输出。第一步先从film中找到需要的行。因为在flim_id字段上有主键索引，所以MySQL优化器知道这只会返回一行数据，优化器在生产执行计划的时候，就已经很通过索引信息知道将返回多少行数据。因为优化器已经明确知道有多少个值（WHERE 条件中的值）需要做索引查询，索引这里的表的访问类型是const。

​	在执行计划的第二部，MYSQL将第一步中返回的film_id列当作一个已知取值的列来处理。因为优化器清楚在第一步执行完成后，该值就会是明确的了。注意到正如第一步中一样，使用film_actor字段对表的访问类型也是const。

​	另一种会看到常数条件的情况是通过等式将常数值从一个表传到另一个表，这可以通过where、using或者on语句来限制某些取值为常数。在上面的例子中，因为使用了using子，优化器知道了这也限制了film_id在整个查询过程中都始终是以个常量--因为它必须等于WHERE子句中的那个取值。

**覆盖索引扫描**

​	当索引中更多列包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无须查询对应的数据行，在前面的章节中我们已经讨论过这点了。

**子查询优化**

​	MySQL在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。

**提前终止查询**

​	在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。一个典型的例子就是当使用了LIMIT子句的时候。除此之外，MYSQL还有几类情况也会提前终止查询，例如发现了一个不成立的条件，这时MYSQL可以立刻返回一个空结果。从下面的例子可以看到这一点：

​	<img src="images/image-20210322112213704.png" alt="image-20210322112213704" style="zoom:50%;" />

​	从这个例子看到查询在优化阶段就已经终止。除此之外，MYSQL在执行过程中，如果发现某些特殊的条件，则会提前终止查询。当存储引擎需要检索“不同的值”或者判断存在性的时候，MYSQL都可以使用这类优化。例如，我们现在需要找到没有演员的所有电影：

```mysql
select film.film_id
from sakila.film
	left outer join sakila.film_actor using(film_id)
where film_actor.film_id is null
```

​	这个查询将会过滤掉所有演员的电影。每一步电影可能会有很多的演员，但是上面的查询一旦找到任何一个，就会立刻平判断下一部电影，因为只要有一名演员，那么where条件就会过滤掉这类电影。类似这种 “不同值/不存在”的优化一般可用于DISTINCT、NOT EXIST（）或者LEFT JOIN类型的查询。

**等值传播**

​	如果列的值通过等式关联，那么MySQL能够把其中一个列的where条件传递到另一列上。例如，我们看下面的查询：

```mysql
select film.film_id
	from sakila.film
		inner join sakila.film_actor using(film_id)
	where film.film_id > 500
```

​	因为这里使用了film_id字段进行等值关联，MySQL知道这里的WHERE子句不仅适用于film表，而且对于film_actor表同样适用。如果使用的是其他的数据库管理系统，可能还需要手动通过一些条件来告知优化器这个WHERE条件适用于两个表，那么写法就会如下：

```mysql
...where film.film_id > 500 and film_actor.film_id > 500
```

​	在MySQL中这是不必要的，这样写反而会让查询更难维护。

**列表In（） 的比较**

​	在很多数据库系统中，IN（） 完全等同于多个OR条件的子句，因为这两者是完全等价的。在MYSQL中这点是不成立的，MYSQL将IN（） 列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个O（logn）复杂度的操作，等价地转换成OR查询的复杂度为O（n)，对于IN（） 列表中有大量取值的时候，MYSQL的处理速度将会更快。



上面列举的远不是MYSQL优化器的全部，MYSQL还会做大量其他的优化，即使本章全部来描述也会篇幅不足，但上面的这些例子足以让大家明白优化器的复杂性和智能性了。如果说上面这段讨论中我们应该学到什么，那就是“不要自以为比优化器更聪明”。最终你可能会站点便宜，但更有可能会使查询变得更佳复杂而难以维护，而最终的收益却为零。让优化器按照它的方式工作就可以了。

当然，虽然优化器已经很智能了，但是有时候也无法给出最优的结果。有时候你可能比优化器更了解数据，例如，由于应用逻辑是使得某些条件总是成立；还有时，优化器缺少某种功能特性，如哈希索引；再如前面提到的，从优化器的执行成本角度评估出来的最优执行计划，实际运行中可能比其他的执行计划更慢。

如果能够确认优化器给出的不是最佳选择，并且清楚背后的原理，那么也可以帮助优化器做进一步的优化。例如，可以在查询中添加hint提示，也可以重写查询，或者重新设计跟优的库表结构，或者添加更合适的索引。

#### 数据和索引的统计信息

重新回忆一下图1-1，MySQL架构由多个层次组成。在服务器层有查询优化器，却没有保存数据和索引的统计信息。统计信息由存储引擎实现，不同的存储引擎可能会存储不同的统计信息（也可以按照不同的格式存储统计信息）。某些引擎，例如Archive引擎，则根本就没有存储任何统计信息！

因为服务器层没有renew统计信息，所以MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，包括：每个表或者索引由多少个页面、每个表的索引的基数是多少、数据行和索引长度、索引的分布信息等。优化器根据这些信息来选择一个最优的执行计划。在后面的小节中我们将会看到统计信息是如何影响优化器的。

**MySQL如何执行关联查询**

MySQL中“关联”一次🔒包含的意义比一般意义上理解的要更广泛。总的来说，MySQL认为任何一次查询都是一次“关联”--并不是仅仅是一个查询需要到两个表匹配才叫关联，所以在MYSQL中，每一个查询，每一个片段（包括子查询，甚至基于但表的SELECT）都可能是关联。

所以，理解MySQL如何执行关联查询至关重要。我们先来看一个UNION查询的例子。对于UNION查询，MYSQL先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成UNION查询。在MYSQL的概念中，每个查询都是一次关联，所以读取临时表也是一次关联。

当前MYSQL关联执行的策略很简单：MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配到行，依次下去，直到找到所有表中匹配到行位置。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL返回到上一层次关联表，看是否能够找到更多的匹配记录，依次类推迭代执行。

> 后面我们会看到MySQL查询执行的过程没有这么简单，MySQL做了很多优化操作。

按照这样的方式查找第一个表记录，再嵌套查询下一个关联表，然后回溯到上一个表，在MySQL中通过嵌套循环到方式实现--正如其名“嵌套循环关联”。请看下面的例子中的简单查询：

```mysql
select tbl1.col1,tbl2.col2
	from tbl1 inner join tbl2 using(col3)
where tbl1.col1 in(5,6)
```

假设MySQL按照查询中的表顺序进行关联操作，我们则可以用下面的伪代码表示MySQL将如何完成这个查询：

```mysql
outer_iter = iterator over tbl1 where col1 in(5,6)
outer_row = outer_iter.next
while out_row
	inner_iter = iterator over tbl2 where col3 = out_row.col3
	inner_row = inner_iter.next
	while inner_row
		output[out_row.col1, inner_row.col2]
		inner_row = inner_iter.next
	end
	out_row = out_iter.next
end
```

上面的执行计划对于单表查询和多表关联查询都适用，如果是一个单表查询，那么只需完成上面外层的基本操作。对于外连接上面的执行过程仍然适用。例如，我们将上面查询修改如下：

```mysql
select tbl1.col1,tbl2,col2
	from tbl1 left out join tbl2 using(col3)
where tbl1.col1 in(5,6)
```

对应的伪代码，我们用黑体表示不同部分

```mysql
outer_iter = iterator over tbl1 where col1 in(5,6)
outer_row = outer_iter.next
while outer_row
	inner_iter = iterator over tbl2 where col3 = out_row.col3
	inner_row = inner_iter.next
	if inner_row
		where inner_row
			output [outer_row.col1, inner_row.col2]
			inner_row = inner_iter.next
		end
	else
		output [out_row.col1,NULL]
	end
	out_row = outer_iter.next
end
```

另一种可视化查询执行计划的方法是根据优化器执行的路径绘制出对应的“泳道图”。如图6-2所示，绘制了前面示例中内连接的泳道图，请从左至右，从上至下地看这幅图。

<img src="images/image-20210322131225431.png" alt="image-20210322131225431" style="zoom:50%;" />

从本质上说，MySQL 对所有的类型的查询都以同样的方式运行。例如，MySQL在FROM子句中遇到子查询时，先执行子查询并将其结果放到一个临时表中，

> MySQL的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点，这一点对UNION查询也一样。

然后将这个临时表当作一个普通表对待（正如其名“派生表”）。MySQL在执行UNION查询时也适用类似的临时表，在遇到右外连接的时候，MySQL将其改写成等价的左外连接。简而言之，当前版本的MySQL会将所有的查询类型都转换成类似的执行计划。

> 在MySQL5.6和MairaDB中有了重大改变，这两个版本都引入了更佳复杂的执行计划。

不过，不是所有的查询都可以转换成上面的形式。例如，全外连接就无法通过嵌套循环和回溯的方式完成，这时当发现关联表中没有找到任何匹配行的时候，则可能是因为关联是恰好从一个没有任何匹配的表开始。这也大概是MySQL并不支持全外连接的原因。还有些场景，虽然可以转换成嵌套循环的方式，但是效率却非常差，后面我们会看到一个这样的例子。

#### 执行计划

和很多其他关系数据库不同，MySQl并不回生成查询字节码来执行查询。MySQL生成查询的一棵指令树，然后通过存储引擎执行完成这棵指令树并返回结果。最终的执行计划包含了重构查询的全部信息。如果对某个查询执行EXPLAIN EXTENED后，再执行SHOW WARNINGS，就可以看到重构出的查询。

> MySQL根据执行计划生成输出，这和原查询有完全相同的语义，但是查询语句可能并不完全相同。

任何多表查询都可以使用一棵树表示，例如，可以按照图6-3执行一个四表的关联操作。

<img src="images/image-20210322132113850.png" alt="image-20210322132113850" style="zoom:50%;" />

在计算机科学中，这被称为一棵平衡树。但是，这并不是MySQL执行查询的方式。正如我们前面章节介绍的，MySQL总是从一个表开始一直嵌套循环、回溯完成所有表的关联。所以，MysQL的执行计划总是如图6-4所示，是一棵左侧深度优先的树。

<img src="images/image-20210322132230886.png" alt="image-20210322132230886" style="zoom:50%;" />

#### 关联查询优化器

MySQL优化器最重要的一部分就是关联查询优化，它决定多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果。关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。

下面的查询可以通过不同顺序的关联最后都获得相同的结果：

```mysql
select film.film_id, film.title, film.release_year, actor.actor_id, actor.first_name, actor.last_name
from sakila.film
inner join sakila.film_actor using(film_id)
inner join sakila.actor using(actor_id)
```

容易看出，可以通过一些不同的执行计划来完成上面的查询。例如，MySQL可以从film表开始，使用film_actor表的索引film_id来查找对应的actor_id值，然后再根据actor表的主键找到对应的记录。Oracle用户会用下面的术语描述：“film表作为驱动表先查找film_acotr表，然后以此结果为驱动表再查找actor表”。这样做效率应该会不错，我们再使用EXPLAIN来看看MySQL将如何执行这个查询：

<img src="images/image-20210322133305328.png" alt="image-20210322133305328" style="zoom:50%;" />

这和我们前面给出的执行计划完全不同。MySQL从actor表开始（我们从上面的EXPLAIN结果的第一行输出可以看出这点），然后与我们前面的计划按照相反的顺序进行关联。这样是否效率更高呢？我们来看看，我们先使用STRAGHT_JOIN关键字，按照我们之前的顺序执行，这里是对应的EXPLAIN输出结果：

​															<img src="images/image-20210322133602068.png" alt="image-20210322133602068" style="zoom:50%;" />	

我们来分析一下为什么MySQL会将关联顺序倒转过来：可以看到，关联顺序倒转后的第一个关联表只需要扫描很少的行数。

> 严格来说，MySQL并不根据读取的记录来选择最后的执行计划。实际上，MySQL通过预估需要读取的数据页来选择，读取的数据页越少越好。不过读取的记录数通常很好地反映一个查询的成本。

在两种关联顺序下，第二个和第三个关联表都是根据索引查询，速度都很快，不同的是需要扫描的索引项的数量是不同的：

- 将film作为第一个关联表时，会找到951条记录，然后对film_actor和actor表进行嵌套循环查询。
- 如果MySQL选择首先扫描actor表，只会返回200条记录进行后面的嵌套循环查询。

换句话说，倒转的关联顺序会让查询进行更少的嵌套循环和回溯操作。为了验证优化器的选择是否正确，我们单独执行这两个查询，并且看看对应的Last_query_cost状态值。我们看到倒转的关联顺序的预估成本为241，而原来的查询的预估成本为1154。

这个简单的例子主要想说明MySQL是如何选择合适的关联顺序来让查询执行的成本尽可能低的。重新定义关联的顺序是优化器非常重要的一部分功能。不过有时候，优化器给出的并不是最优的关联顺序。这时可以使用STRAIGHT_JOIN关键字重写查询，让优化器按照你认为最优的关联顺序执行-不过老实说，人的判断很难那么精准。绝大多数时候，优化器做出的选择都比普通人的判断都要更准确。

关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树。如果可能，优化器会便利每一个表然后逐个做嵌套循环计算每一颗可能的执行计划树的成本，最后返回一个最优的执行计划。

不过，糟糕的是，如果有超过n个表的关联，那么需要检查n的阶乘种关联顺序。我们称之为所有可能的执行计划的“搜索空间”，搜索空间的增长速度非常快--例如，若是10个表的关联，那么共有3628800种不同的关联顺序！当搜索空间非常大的时候，优化器不可能逐一评估每一种关联顺序的成本。这时，优化器选择使用“贪婪”搜索的方式查找“最优”的关联顺序。实际上，当需要关联的表超过optimizer_search_depth的限制的时候，就会选择“贪婪”搜索模式了（optimizer_search_depth参数可以根据需要指定大小）。

在MySQL这些年的发展过程中，优化器积累了很多“启发式”的优化策略来加速执行计划的生成。绝大多数情况下，这都是有效的，但因为不会取计算每一种关联顺序的成本，所以偶尔也会选择一个不是最优的执行计划。

有时，各个查询的顺序并不能随意安排，这时优化器可以根据这些规则大大减少搜索空间，例如，左连接、相关子查询（后面我将继续讨论子查询）。这时因为，后面的表的查询需要依赖于前面表的查询结果。这种依赖关系通常可以帮助优化器大大减少需要扫描的执行计划数量。

#### 排序优化

无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。

**在第3章我们已经看到MySQL如何通过索引进行排序。当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序（filesort)，即使完全是内存排序不需要任何磁盘文件时也是如此。**

**如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的快使用“快速排序”进行排序，并将各个快的排序结果放在磁盘上，然后将各个排好序的快进行合并（merge），最后返回排序结果。**

MySQL有如下两种排序算法：

**两次传输排序（旧版本使用）**

​	读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。

​	这需要进行两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这会产生大量的随机I/O，所以两次数据传输的成本非常高。当使用的是MyISAM表的时候，成本可能会更高，因为MyISAM使用系统调用进行数据读取（MyISAM非常依赖操作系统对数据的缓存）。不过这样做的有点时，在排序的时候存储尽可能少的数据，这就让“排序缓冲区”中尽可能多的行数进行排序。

**单次传输排序（新版本使用）**

​	先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。这个算法只在4.1和后续更新的版本才引入。因为不再需要从数据表中读取两次数据，对于I/O密集型的应用，这样做的效率高了很多。另外，相比两次传输排序，这个算法只需要一次顺序I/O读取所有的数据，而无须任何随机I/O。缺点是，如果需要返回的列非常多、非常大，会额外占用大量的空间，而这些列对排序操作本身来说是没有任何作用的。因为单挑排序记录很大，所以可能会有更多的排序块需要合并。



很难说哪个算法效率更高，两种算法都有各自最好和最糟的场景。当查询需要所有列的总长度不超过max-length-for-sort-data时，MySQL使用“”单词传输排序“，可以通过吊证这个参数来影响MySQL排序算法的选择。关于这个细节。可以参考第8章”文件排序优化“。

MySQL在进行文件排序的时候需要使用的临时存储空间可能会比想象的要大得多。原因在于MySQL在排序时·，对每一个排序记录都会分配一个足够长的定长空间来存放。

这个定长空间必须足够长以容纳其中最长的字符串，例如，例如，如果是VARCHAR列则需要分配其完整长度；如果使用UTF-8字符集，那么MySQL将会为每个字符预留三个字节。我们曾经在一个库表结构设计不合理的案例中看到，排序消耗的临时空间比磁盘上的原表要大很多倍。

在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。如果Order By子句中的所有列都来自关联的第一个表，那么MySQL在关联处理第一个表的时候就进行文件排序。如果是这样，那么MySQL的EXPLAIN结果中可以看到Extra字段会有“Using filesort”。除此之外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后在所有的关联都结束后，再进行文件排序。这种情况下，在MySQL的EXPLAIN结果的EXtra字段可以看到“Using temporary；Using filesort”。如果查询中有LIMIT的话，LImiT也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大。

**MySQL5.6在这里做了很多重要的改进。当只需要返回排序结果的时候，例如使用LIMIT子句，MySQL不再对所有的结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后再进行排序。**

### 6.4.4 查询执行引擎

在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询引擎则根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和很多其他的关系型数据库那样会生成对应的字节码。

相对于查询优化阶段，查询执行阶段不是那么复杂：MySQl知识简单地根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程汇总，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口也就是我们称为“hander API”的接口。查询中的每一个表由一个hanlder的实例表示。前面我们有意忽略了这点，实际上，MySQL在优化阶段就为每个表创建了一个handler实例，优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名、索引统计信息，等等。

存储引擎接口有着非常丰富的功能，但是底层接口却只有几十个，这些接口像“搭积木”一样能够完成查询的大部分操作。例如，有一个查询某个索引的第一行的接口，再有一个查询某个索引条目的下一条目的功能，有了这两个功能我们就可以完成全索引扫描的操作了。这种简单的接口模式，让MySQL的存储引擎插件式架构称为可能，但是正如前面的讨论，也给优化器带来了一定的限制。

> 并不是所有的操作有由handler完成。例如，当MySQL需要进行表锁的时候，handler可能会实现自己的级别的、更细粒度的锁，如In弄DB就实现了自己的行基本锁，但这并不能代替服务器层的表锁。正如我们第1章锁介绍的，如果是所有饿存储引擎共有的特性则由服务器层实现，比如时间和日期函数、视图、触发器等。

为了执行查询，MySQL只需要重复执行计划中的各个操作，直到完成所有的数据查询。

### 6.4.5 返回结果给客户端

查询执行的最后一个阶段是将结果返回给客户端。即使查询不需要返回结果集给客户端，MySQL仍然会返回这个查询的一些信息，如该查询影响到的行数。

如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到查询缓存中。

MySQL将结果集返回给客户端是一个增量、逐步返回到过程。例如，我们回头看看前面的关联操作，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。

这样处理有两个好处：服务器端无须存储太多的结果，也就不回因为要返回太多结果而消耗太多内存。另外，这样的处理也让MySQL客户端第一时间获得返回的结果。

> 可以通过一些办法来影响这个行为--例如，我们可以使用SQL_BUFFER_RESULT。参考后面的“查询优化提示”。



## 6.5 MySQL查询优化器的局限性

MySQL的万能“嵌套循环”并不是对每种查询都是最优的。不过还好，MySQL查询优化器只对少部分查询不适用，而且我们往往可以通过改写查询让MySQL高效地完成工作。还有一个好消息，MySQL5.6版本正式发布后，会消除很多MySQL原本对限制，让更多的查询能够以尽可能高的效率完成。

### 6.5.1 关联子查询

MySQL的子查询实现得非常糟糕。最草稿的一类查询是WHERE条件中包含IN（） 的子查询语句。例如，我们希望找到SAKILA数据中，演员Penelope Guiness（他的actor_id为1）参演过的所有影片信息。很自然的，我们会按照下面的方式用子查询实现：

```mysql
select * from sakila.film
where film_id in (
	select film_id from sakila.film_actor where actor_id = 1);`
```

因为MySQL对IN（）列表中的选项有专门的优化策略，一般会认为MySQL会先执行子查询返回所有包含actor_id为1的film_id。一般来说，In（）列表查询速度很快，所以我们会认为上面会这样执行：

```mysql
select goup_cancat(film_id) from sakila.film_actor where acotr_id = 1;
Result : 1,23,25,106,...,939,970,980
select film id in (1,23,25,...,980);
```

很不幸，MySQL不是这样做的。MySQL会将相关的外表压到子查询中，它认为这样可以更高效率地查找到数据行，也就是说，MySQL会将查询改写成下面的样子：

```mysql
select * from sakila.film
where exists(
	select * from sakil.film_actor where acotr_id = 1
	and film_actor.film_id = film.film_id
);
```

这时，子查询需要根据film_id来关联外部表film，因为需要film_id字段，所以MySQL认为无法先执行这个子查询。通过expalin我们可以看到子查询是一个相关子查询（dependent subquery） （可以使用expain extened来查询这个查询被改写成了什么样子；

<img src="images/image-20210324093759493.png" alt="image-20210324093759493" style="zoom:50%;" />

根据EXPLAIN的输出我们可以看到，MySQL先选择对film表进行全表扫描，然后根据返回的film_id逐个执行子查询。如果是一个很小的表，这个查询糟糕的性能可能还不会引起注意，但是如果外层的表是一个非常大的表，那么这个查询的性能会非常糟糕。当然我们很容易用下面的办法来重写这个查询：

```mysql
select film.* from sakil.film 
	inner join sakila.film actor using(film_id)
where acotr_id = 1;
```

另一个优化的办法是使用函数group_concat()在IN（） 中构造一个由逗号分隔的列表。有时这比上面的使用关联改写得更快。因为使用IN（） 加子查询，性能经常会非常糟糕，所以通常建议使用EXISTS()等效的改写查询来获取更好的效率。下面是另外一种改写IN()加子查询的办法：

```mysql
select * FROM sakila.film 
where exists(
	select * from sakila.film_actor where actor_id = 1
		and film_actor.film_id = film.film_id
);
```

> 这里讨论的优化器的限制直到Oracle推出的mySQL5.5都一直存在，MySQL的一个分支mariaDB则在原有的优化器的基础上做了大量的改进，例如这里提高的IN（） 加子查询改进。

**如何用好关联子查询**

并不是所有关联子查询的性能都会很差。如果有人跟你说：“别用关联子查询”，那么不要理他。先测试，然后做出自己的判断。很多时候，关联子查询是一种非常合理、自然，甚至是性能最好的写法。我们先看看那下面的例子：

<img src="images/image-20210324095942174.png" alt="image-20210324095942174" style="zoom:50%;" />

一般会建议使用左连接(left outer join)重写该查询，以代替子查询。理论上，改写后mySQL的执行计划完全不会改变。我们来看看这个例子：

<img src="images/image-20210324100121018.png" alt="image-20210324100121018" style="zoom:50%;" />

可以看到，这里的执行计划基本上一样，下面是一些微小的区别：

- 表film_actor的访问类型是一个dependent subquery，而另一个是simple。这个不同是由于语句的写法不同导致的，一个是普通查询，一个是子查询。这对底层存储引擎接口来说，没有任何不同。

- 对film表，第二个查询的extra中没有“using where”，但这不重要，第二哥查询的using子句和第一个查询的where子句实际上是完全一样的。

  在第二个表film_actor的执行计划的extra列有“not exists”。这时我们前面章节中提到的提前终止算法，mySQL通过使用“NOT exists”优化来避免表film_actor的索引中读取任何额外的行。这完全等效于直接编写not exists子查询，这个执行计划也是一样，一旦匹配到一行数据，就立刻停止扫描。

所以，从理论上讲，MySQl讲使用完全相同的执行计划来完成这个查询。显示世界中，我们建议通过一些测试来判断使用哪种写法速度会更快。针对上面的案例，我们对两种写法进行了测试，表6-1中列出了测试结果。

![image-20210324100835814](images/image-20210324100835814.png)

我们对测试显示，使用子查询对写法要略微慢些！

不过每个具体的案例会各有不同，有时候子查询写法也会快些。例如，当返回结果中只有以个表中的某些列的时候。听起来，这种情况对于关联效率也会很好。具体情况具体分析，例如下面的关联，我们希望返回所有包含同一个演员参演的电影，因为一个电影会有很多演员参演，所以可能会返回一些重复的记录：

<img src="images/image-20210324101313041.png" alt="image-20210324101313041" style="zoom:50%;" />

但是，回头再看看这个查询，到底这个查询返回的记过意义是什么？至少这样的写法会让SQL的意义很不明显。如果使用EXISTS则很容易表达“包含同一个参演演员”的逻辑，而且不需要使用distinct和group by ，也不会产生重复的结果集，我们知道一旦使用了DISTINCT 和group by，那么在查询的执行过程中，通常需要产生临时中间表。下面我们用子查询的写法替换上面的关联；

```java
select film_id from sakila.film
	where exists(select * from sakila.film_actor
	where film.film_id = film_actor.film_id);
```

在一次，我们需要通过测试来对比这两种写法，哪个更快一些。测试结果参考表6-2。

<img src="images/image-20210324101827342.png" alt="image-20210324101827342" style="zoom:50%;" />

在这个案例中，我们看到子查询速度要比关联查询更快些。

通过上面这个详细的案例，主要想说明两点：意识不需要听取哪些关于子查询的“绝对真理”，而是应该用测试来验证对子查询的执行计划和相应时间的假设。最后，关于子查询我们需要提到的是一个MySQL的BUG。在早起版本，下面的写法会锁住table2中的一条记录：

```mysql
selecct ... from table1 where col = (select ... from tables where ...);
```

如果遇到该bug，子查询在高并发情况下的性能，就会和在单线程测试时的性能相差甚远。虽然这个问题已经被修复了，但是我们仍然要提醒读者：不要猜测，应该通过测试来验证猜想。

### 6.5.2 UNION 的限制

有时，MySQL无法讲限制条件从外层“下推”到内层，这使得原本能够限制部分返回结果的条件无法应用到内层查询到优化上。

如果希望UNION的各个子句能够根据LIMIT只取部分集，或者希望能够闲排好序再合并结果集的话，就需要在UNION的各个子句中分别使用这些子句。例如，想将两个子查询结果联合起来，然后再取前20条记录，那么MySQl会将两个表都存放到同一个临时表中，然后再取出前20行记录：

```mysql
(select first_name,last_name from sakila.actor order by last_name)
union all
(select first_name,last_name from sakila.customer order by last_name)
limit 20;

```

这条查询将会把actor中的200条记录和customer表中的599条记录存放在一个临时表中，然后再从临时表中取出前20条。可以通过在UNION的两个子查询中分别加上一个LIMIT20来减少临时表中的数据：

```mysql
（select first name ,last_name
from sakila.actor
odder by last_name
limit 20)
union all 
(select first_name, last_name
from sakila.customer
order by last_nmae
limit 20)
limit 20
```

现在中间的临时表只会包含40条记录了，除了性能考虑之外，在这里还需要注意一点：从临时表中取出数据的顺序并不是一定的，所以如果想获取正确的顺序，还需要加上一个全局的order by 和limit 操作。

### 6.5.3 索引合并优化

在前面的章节已经讨论过，在5.0和更新的版本中，当where子句中包含多个复杂条件的时候，MysQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。

### 6.5.4 等值传递

某些时候，等值传递会带来一些意想不到的额外消耗。例如，有一个非常大的IN（）列表，而MySQL优化器发现存在WHERE、ON或者USING的子句，将这个列表的值和另一个表的某个列相关联。

那么优化器会将IN（）列表都复制应用到关联的各个表中。通常，因为各个表新增了过滤条件，优化器可以更高效地从存储引擎过滤记录。但是如果这个列表非常大，则会导致优化和执行都会变慢。该问题不好被绕过。

### 6.5.5 并行执行

MySQL无法利用多核特性来并行执行查询。很多其他的关系型数据库能够提供这个特性，但是mySQL做不到。这里特别指出是想告诉读者不要花时间去尝试寻找并行执行查询的方法。

### 6.5.6 哈希关联

在本书写作的时候，MySQL并不支持哈希关联-mySQL的所有关联都是嵌套循环关系。不过，可以通过建立一个哈希索引来曲线地实现哈希关联。如果使用的是memory存储引擎，则索引都是哈希索引，所以关联的时候也类似于哈希关联。另外MariaDB以ing实现了真正的哈希关联。

### 6.5.7 松散索引扫描

由于历史原因，MySQl并不支持松散索引扫描，也就无法按照不连续的方式扫描以个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这个索引中很少的几个，MysQL仍需要扫描则断索引中的每一个条目。

下面我们通过一个示例说明这点。假设我么有如下索引（a,b)，有下面的查询：

```mysql
select ... from tb1 where b between 2 and 3;
```

因为索引的前导字段是列a，但是在查询中指定了字段b，MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行，如下图所示。

<img src="images/image-20210324105433032.png" alt="image-20210324105433032" style="zoom:50%;" />

了解索引的物理结构的话，不难发现还有一个更快的办法执行上面的查询。索引的物理结构使得可以先扫描a列的第一个值对应的b列的范围，然后再跳到a列的第二个不通知扫描对应的b列的范围。下图展示了如果由MySQL来实现这个过程会怎样。

<img src="images/image-20210324105628138.png" alt="image-20210324105628138" style="zoom:50%;" />

注意到，这时就无须再使用where子句过滤，因为松散索引扫描已经跳过了所有不需要的记录。

上面是一个简单的例子，除了松散索引，新增一个合适的索引当然也可以优化上述查询。但对于某些场景，增加索引是没用的，例如，对于第一个所以列是范围条件，第二个索引列是等值条件的查询，靠增加索引就无法解决问题。

MysQL5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值：

<img src="images/image-20210324110118657.png" alt="image-20210324110118657" style="zoom:50%;" />

在EXPLAIN的EXTRA字段显示“Using index for group-by”，表示这里将使用松散索引扫描，不过如果Mysql能写上“loose index probe”，乡音会更好理解。

在MySQL很好地支持松散索引扫描之前，一个简单的绕过问题的办法就是给前面的列加上可能的常数值。在前面索引案例学习的章节中，我们已经看到这样做的好处了。

在MSQL5.6之后的版本，关于松散索引扫描的一些限制将会通过“索引条件下推（index condition pushdown）”的方式解决。

### 6.5.8 最大值和最小值优化

对于MIN（） 和MAX（）查询，MySQl的优化做得并不好。这里有一个例子：

```mysql
select min(actor_id) from sakila.actor where first_name = 'penelope';
```

因为在first_name字段上并没有索引，因此MysQL将会进行一次全表扫描。如果MySQL能够尽兴主键扫描，那么理论上，当MySQL读到第一个满足条件的记录的时候，就是我们需要找的最小值了，因为主键是严格按照actor_id字段的大小顺序排列的。但是MySQl这时只会做全表扫描，我们可以通过查看show status的全表扫描计数器来验证这一点。一个曲线的优化办法是移除min()，然后使用limit来将查询重写如下:

```mysql
select actor_id from sakila.actor using index(primary)
where first_name = 'penelope' limit 1;
```

这个策略已经可以让MySQl扫描尽可能少的记录数。如果你是一个完美主义者，可能会说这个SQL已经无法表达她的本意了。一般我们通过SQL告诉服务器我们需要什么数据，由服务器来决定如何最优地获取数据，不过这个案例中，我们其实是告诉MySQL如何获取我们需要的数据，通过SQL并不能一眼就看出我们其实是想要一个最小值。确实如此，有时候为了获取跟高的性能，我们不得不放弃一些原则。

### 6.5.9 在同一个表上查询和更新

MySQL不允许对同一张表同时进行查询和更新。这其实并不是优化器的限制，如果清楚MySQl是如何执行查询的，就可以避免这种情况。下面是一个无法运行的SQl，虽然这是一个符合标准的SQL语句。这个SQL语句尝试将两个表中相似行的数量记录到字段cnt中：

```mysql
update tb1 as out_tb1
	set cnt = (
		select count(*) from tb1 as inner_tb1
		where inner_tb1.type = outer_tb1.type
	);
```

可以通过使用生成表的形式来绕过上面的限制，因为mySQL只会把这个表当作一个临时表来处理。实际上，这执行了两个查询：一个是子查询中的SELECT语句，另一个是多表关联UPDATE，只是关联的表是一个临时表。子查询会在UPDATE语句打开表之前就完成，所以下面的查询将会正常执行：

## 6.6 查询优化器的提示（hint）

如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示（hint）来控制最终的执行计划。下面将列举一些常见的提示，并简单地给出什么时候使用该提示。通过在查询中加入相应的提示，就可以控制该查询的执行计划。关于每个提示的具体用法，建议直接阅读MYSQL官方手册。有些提示和版本有直接关系。可以使用的一些提示如下：

![image-20210324113127952](images/image-20210324113127952.png)

![image-20210324113212824](images/image-20210324113212824.png)

![image-20210324113349179](images/image-20210324113349179.png)

![image-20210324113427956](images/image-20210324113427956.png)

> **MySQL升级后的验证**
>
> 在优化器前耍一些小聪明是不好的。这样做收效甚小，但是却给维护带来了很多额外的工作量。在MySQL版本升级的时候，这个问题就很突出了，你设置的“优化器提示”很可能会让新版的优化策略生效。
>
> MySQL 5.0 版本引入了大量优化策略，在在没有正式发布的5.6版本中，优化器的改进也是近些年最大的一次改进。
>
> 新版MySQl基本上在各个方面都有非常大的改进，5.5和5.6折两个版本尤为突出。升级操作一般来说都很顺利，但仍然建议仔细检查各个细节，以防止一些边界情况影响你的应用程序。不过还好，要避免这些，你不需要付出太多的精力。使用Percona Toolkit 中的pt-upgrade，就可以检查在新版本中运行的SQL是否与老版本意义，返回相同的结果。

## 6.7 优化特点类型查询

这一节，我们将介绍如何优化特定类型的查询。在本书的其他部分都会分散介绍这些优化技巧，不过这里将会汇总一下，以便参考和查阅。

本节介绍的多数优化技巧都是和特点的版本有关的，所以对于未来MySQL的版本未必适用。毫无疑问，某一天优化器自己也会实现这里列出的部分或者全部优化技巧。

### 6.7.1 优化COUNT（）查询

COUNT()聚合函数，以及如何优化使用了该函数的查询，很可能是MySQL中最容易被误解的前10个话题之一。在网上随便搜索一下就能看到很多错误的理解，可能比我们想象的多得多。

在做优化之前，先看看COUNT（） 函数真正的作用是什么。

#### COUNT（） 的作用

COUNT（） 是一个特殊的函数，有两种非常不同的作用：它可以统计某个列的数量，也可以统计行数。在统计列值时要求列值是非空的（不统计NULL）。如果在COUNT（）的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。因为很多人对NULL理解有问题，所以这里很容易产生误解。如果想了解更多关于SQL语句中NULL的含义，建议阅读一些SQL语句基础的书籍。

COUNT（） 的另一个作用是统计结果集的行数。当MySQL确认括号内的表达式值不可能为空格时，实际上就是在统计行数。最简单的就是当我们使用COUNT（\*）的时候，这种情况下通配符*并不会像我们猜想的那样扩展成所有列，实际上，它会忽略所有的列而直接统计所有的行数。

我们发现一个最常见的错误就是，在括号内指定了一个列却希望统计结果集的行数。如果希望知道的是结果集的行数，最好使用COUNT（*），这样写意义清晰，性能也会很好。

#### 关于MyISAM的神话

一个容易产生的误解就是：MyISAM的COUNT（）函数总是非常快，不过这是有前提条件的，即只是没有任何WHERE条件的COUNT（*）才非常快，因为此时无须实时地去计算表的行数。MySQL可以利用存储引擎的特性直接获得这个值。如果MySQL知道某列col不可能为NUL了值，那么MySQL内部会将COUNT（col）表达式优化为COUNT（*）。

当统计带WHERE子句的结果集行数，可以是统计某个列值的数量时，MyISAM的COUNT（） 和其他存储引擎没有任何不同，就不再有神话般的速度了。所以在MyISAM引擎表上执行COUNT（）有时候比别的引擎快，有时候比别的引擎慢，这受很多因素影响，要视具体情况而定。

#### 简单的优化

有时候可以使用MyISAM在COUNT（*）全表非常快这个特性，来加速一些特定条件的COUNT（） 的查询。在下面的例子中，我们使用标准数据库world来看看如何快速查找到所有ID大于5的城市。可以像下面这样来写这个查询：

```mysql
select count(*) from world.City where id > 5;
```

通过show status的结果可以看到该查询需要扫描4097行数据。如果将条件反转一下，先查找ID小于等于5的城市数，然后用总城市数一减就能得到同样的结果，却可以将扫描的行数减少到5行以内：

```mysql
select (select count(*) from world.City) - Count(*)
from world.City
where id <=	5;
```

这样做可以大大减少需要扫描到行数，是因为在查询优化阶段会将其中的子查询直接当作一个常数来处理，我们可以通过EXPLAIN来验证这点：

<img src="images/image-20210326095142911.png" alt="image-20210326095142911" style="zoom:50%;" />

在邮件组和IRC聊天频道，通常会看到这样的问题：如何在同一个查询中统计同一个列的不同值的数量，以减少查询的语句量。例如，假设可能需要通过一个查询返回各种不同颜色的商品数量，以减少查询的语句量。例如，假设可能需要通过一个查询返回各种颜色商品数量，此时不能使用OR语句（比如select count(color='blue' or color = 'red） from items；）因为这样做就无法区分不同颜色商品数量；也不能在where条件中指定颜色（比如select count(*) from items where color = 'blue' and color = 'red'; ），因为颜色的条件是互斥的。下面的查询可以在一定程序上解决这个问题。

```mysql
select sum(if(color='blue',1, 0)) as blue, sum (if(color='red'),1,0) as red 
from items;
```

> 也可以写成这样的sum()表达式，sum(color = 'blue'), sum(color = 'red')

也可以使用count()而不是sum()实现同样的目的，只需要将满足条件设置为真，不满足条件设置为NULL即可：

```mysql
select count(color = 'blue' or null) as blue, count(color = 'red' or null) as red from items;
```

#### 使用近视值

有时候某些业务场景并不要求完全精确的count值，此时可以用近视值来代替。explain出来的有优化器估算的行数就是一个不错的近视值，执行explain并不需要真正地去执行查询，所以成本很低。

很多时候，计算精确值的成本非常高，而计算近视值则非常简单。曾经有一个客户希望我们统计他的网站的当前活跃用户数是多少，这个活跃用户数保存在缓存中，过期时间为30分钟，所以每隔30分钟需要重新计算并放入缓存。因此这个活跃用户数本身就不是精确值，所以使用近似值代替是可以接受的。另外，如果要精确统计在线人数，通常where条件会很复杂，一方面需要剔除当前非活跃用户，另一方面还要剔除系统中某些特定ID的“默认”用户，去掉这些约束对总数的影响很小，但却可能很好地提升该查询的性能。更进一步地优化则可以尝试删除distinct这样的约束来避免文件排序。这样重写过的查询要比原来的精确统计的查询快很多，而返回的结果则几乎相同。

#### 更复杂的优化

通常来说，count（）都需要扫描大量的行（意味着要访问大量数据）才能获得精确的结果，因此是很难优化的。除了前面的方法，在MySQL层面还能做的就只有索引覆盖扫描了。如果这还不够，就需要考虑修改应用更多架构，可以增加汇总表（第4章已经介绍过），或者增加类似Memcached这样的外部缓存系统。可能很快你就会发现陷入到一个熟悉的困境，“快速，精确和实现简单”，三者永远只能满足其二，必须舍掉一个。

### 6.7.2 优化关联查询

这个话题基本上整本书都在讨论，这里需要特别提到的是：

- 确保ON 或者USING子句的列上有索引。在创建索引的时候就要考虑关联的顺序。当表A和表B用列C关联的时候，如果优化器的关联顺序是B、A，那么就不需要在B表的对应列上建上索引。没有用到的索引只会带来额外的负担。一般来说，除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引。
- 确保任何GROUP BY 和ORDER BY中的表达式只涉及到一个表的列，这样MySQL才有可能使用索引来优化这个过程。
- 当升级MySQL的时候需要注意：关联语法、运算符优先级等其他可能会发生变化的地方。因为以前是普通关联的地方可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果等。

### 6.7.3 优化子查询

关于子查询优化我们给出的最重要的优化建议就是尽可能使用关联查询代替，至少当前的MySQL版本需要这样。前面章节已经详细介绍了这点。“尽可能使用关联”并不是绝对的，如果使用的是MySQL5.6或更新的版本或者MariaDB，那么就可以直接忽略关于子查询的这些建议了。

### 6.7.4 优化Group by 和 Dinstinct

在很多场景下，MySQL都使用同样的办法来优化这两种查询，事实上，MySQL优化器会在内部处理的时候相互转化这两类查询。它们都可以索引索引来优化，这也是最有效的优化办法。

在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略来完成：完成临时表或者文件排序来做分组。对于任何查询语句，这两种策略的性能都有可以提升的地方。可以通过前面提示SQL_BIG_RESULT和SQL_SMALL_RESULT来让优化器按照你希望的方式运行。在本章的前面章节我们已经讨论了这点。

如果需要对关联查询做分组（GROUP BY），并且是按照查找表中的某个列进行分组，**那么通常采用查找表的标识列分组的效率比其他列更高。**例如下面的查询效率不会很好：

```mysql
select actor.first_name, actor.last_name, count(*)
from sakila.film_actor
	inner join sakila.actor using(actor_id)
group by actor.first_name , actor.last_name;
```

如果查询按照下面的写法效率则会更高：

```mysql
select actor.first_name, acotr.last_name, count(*)
from sakila.film_actor
	inner join sakila.actor using(actor_id)
group by filmn_actor.actor_id;
```

使用acotr.actor_id列分组的效率甚至会比使用film_actor.actor_id更好。这一点通过简单的测试即可验证。

这个查询利用了演员的姓名和ID直接相关的特点，因此改写后的结果不受影响，但显然不是所有的关联语句的分组查询都可以改写成在SELECT中直接使用非分组列的形式的。甚至可能会在服务器上设置SQL_MODE来禁止这样的写法。如果是这样，也可以通过MIN（） 或者MAX（）函数来绕过这种限制，但是一定要清楚，SELECT后面出现的非分组列一定是直接依赖分组列，并且在每个组内的值是唯一的，或者是业务上根本不在乎这个值具体 是什么：

```mysql
select min(actor.first_name),max(actor.last_name)，...；
```

较真的人可能会说这样写的分组查询是有问题的，确实如此。从MIN（）或者MAX（） 函数的用法就可以看出这个查询是有问题的。但若更在乎的是MySQL运行查询的效率时这样做也无可厚非。如果实在较真也可以改写成下面的形式：

```mysql
select actor.first_name, actor.last_name,c.cnt 
from sakila.actor
	inner join (
		select actor_id,count(*) as cnt
		from sakila.film_acotr
		group by actor id
	) as c using(actor_id);
```

这样写更满足关系理论，但成本优点高，因为子查询需要创建和填充临时表，而子查询中创建的临时表是咩有任何索引的。

在分组查询的select中直接使用非分组列通常都不是什么好主意，因为这样的结果通常是不定的，当索引改变，或者优化器选择不同的优化策略时都可能导致结果不一样。我们碰到的大多数这种查询最后都导致了故障。而且这种写法大部分是由于偷懒而不是为了优化而故意这么设计的。建议始终使用含义明确的语法。事实上，我们建议将MySQL的SQL_MODE设置为包含ONLY_FULL_GROU_BY, 这时MySQL会对这类的查询直接返回一个错误，提醒你需要重写这个查询。

如果没有通过order by 子句显示地指定排序列，当查询使用group by 子句的时候，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序，而这种默认排序又导致了需要文件排序，则可以使用order by null，让MySQL不再进行文件排序。也可以在GROUP BY子句中直接使用DESC或者ASC关键字，使分组的结果集按需要的方向排序。

#### 优化group by with rollup

分组查询的一个变种就是要求MySQL对返回的分组结果再做一次超级聚合。可以使用WITH ROLLUP子句来实现这种逻辑，但可能会不够优化。可以通过explain来观察其执行计划，特别要注意分组是否是通过文件排序或者临时表实现的。然后再去掉with rollup子句看执行计划是否相同。也可以通过本届前面介绍的优化器提示来固定执行计划。

很多时候，如果可以，在应用程序中做超级聚合是更好的，虽然这需要返回给客户端更多的结果。也可以在from子句中嵌套使用子查询，或者是通过一个临时表存放中间数据，然后和临时表执行union来得到最终结果。

最好的办法是尽可能的将with rollup功能转移到应用程序中处理。

### 6.7.5 优化Limit 分页

在系统中需要进行分页操作的时候，我们通过会使用limit加上偏移量的办法实现，同时加上合适的order by子句。如果有对应的索引，通常效率会不错，否则，MySQl需要做大量的文件排序操作。

一个非常常见又令人头疼的问题就是，在偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这时MySQl需要查询10020条记录然后只返回最后20条，前面10000条记录都将被抛弃，这样的代价非常高。如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大量偏移的性能。

优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候，这样做的效率会提升非常大。考虑下面的查询：

```mysql
select film_id, description 
from sakila.film 
order by title limit 50,5;
```

如果这个表非常大，那么这个查询最好改写成下面的样子：

```sql
select film.film_id, film.description
from sakila.film
	inner join (
		slect film_id from sakila.film
		order by title limit 50,5
	) as lim using(film_id)
```

这里的“延迟关联”将大大提升查询效率，它让MySQl扫描扫描尽可能少的页面，获取需要访问的记录后再根据关联列回到原表查询需要的所有列。这个技术页可以用于优化关联查询中的limit 子句。

有时候也可以将limit查询转换为已知位置的查询，让MySQL通过范围扫描获得到对应的结果，例如，如果在一个位置列上有索引，并且预先计算出了边界值，上面的查询就可以改写为：

```mysql
select film_id ,description from sakila.film
where position between 50 and 54 order by position;
```

对数据进行排名的问题也与此类似，但往往还会同时和group by 混用。在这种情况下通常都需要预先计算并存储排名信息。

limit和offset的问题，其实是offset问题，它会导致mysql扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就i可以避免使用offset 。例如，若需要按照租赁记录做翻页，那么可以根据最新一条租赁记录向后追溯，这样做法可行是因为租赁记录的主键是单挑增长的，首先使用下面的查询获得第一组结果：

```mysql
select * from sakila.rental 
order by rental_id desc limit 20;
```

假设上面的查询返回的是主键为16049到16030的租赁记录，那么下一页查询就可以从16030这个点开始：

```mysql
select * from sakila.rental 
where rental_id < 16030
order by rental_id desc limit 20;
```

该技术的好处是无论翻页到多么后面，其性能都会很好。

其他优化办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做排序的数据列。还可以使用Spinx优化一些搜索操作，参考俘虏F可以获得更多相关信息。

### 6.7.6 优化 SQL_CALC_FOUND_ROWS

分页的时候，另一个常用的技巧就是在limit语句中加上SQL_CALC_FOUND_ROWS提示，这样就可以获得去掉limit以后满足条件的行数，因此可以作为分页的总数。看起来，MySQL做了一些我非常“高深”的优化，像是通过某种方法预测了总行数。但实际上，MySQL只有在扫描了所有满足条件的行以后，才会知道行数，所以加上这个提示以后，不管是否需要，MySQL都会扫描所有满足条件的行，然后在抛弃掉不需要的行，而不是在满足limit的行数后就终止扫描，所以该提示的代价可能非常高。

一个更好的设计是将具体的页数换成“下一页”按钮，假设每页显示20条记录，那么我们每次查询时都是用limit返回21条记录并只显示20条，如果第21条存在，那么我们就显示“下一页”按钮，否则就说明没有更多的数据，也就无须显示“下一页”按钮了。

另一种做法是先获取并缓存较多的数据--例如，缓存1000条---然后每次分页都从这个缓存中获取。这样做可以让应用程序根据结果集的大小采取不同的策略，如果结果集少于1000，就可以在页面上显示所有的分页连接，因为数据都在缓存中，所以这样做性能不会有问题。如果结果集大于1000，则可以在页面上设计一个额外的“找到的结果多于1000条”之类的按钮。这两种策略都比每次生成全部结果集再抛弃掉不需要的数据的效率要高得多。

有时候也可以考虑使用EXPLAIN的结果中的ROWS列的值来作为结果集总数的近似值。当需要精确结果的时候，再单独使用COUNT（*）来满足需求，这时如果能够使用索引覆盖扫描则通常也会比SQL_CALC_FOUND_ROWS快得多。

### 6.7.7 优化UNION查询

MySQL总是通过创建并填充临时表的方式来执行UNION查询。因此很多优化策略在UNION查询中都没法很好地使用。经常需要手工地将WHERE、lIMIT、ORDER BY 等子句“下推”到UNION的各个子查询中，以便优化器可以充分利用这些条件优化（例如，直接将这些子句冗余地写一份到各个子查询）。

除非确实却需要服务器消除重复的行，否则就一定要使用UNION ALL，这一点很重要。如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。即使有ALL关键字，MySQL仍然会使用临时表存储结果。事实上，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候这样做是没有必要的（例如，MySQL可以直接把这些结果返回给客户端）。

### 6.7.8 静态查询分析

Percona Toolkit中的pt-query-adivisor能够解析查询日志、分析查询模式，然后给出所有可能存在潜在问题的查询，并给出足够详细的建议。这像是给MySQL所有的查询做一次全面的健康检查。它能检测出许多常见的问题，诸如我们前面介绍的内容。

### 6.7.9 使用用户自定义变量

用户自定义变量是一个容易被遗忘的MySQL特性，但是如果能够用好，发挥其潜力，在某些场景可以写出非常高效的查询语句。在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。单纯的关系查询将所有的东西都当成无序的数据结合，并且一次性操作它们。MySQL则采用了更佳程序化的处理方式。MySQL的这种方式有它的弱点，但如果能熟练地掌握，则会发现其强大之处，而用户自定义变量也可以给这种方式带来很大的帮助。

用户自定义变量是一个用来存储内容的临时容器，在连接MySQl的整个过程中都存在。

可以使用下面的SET和SELECT语句来定义它们：

```mysql
set @one  := 1;
set @min_actor  := (select min(actor_id) from sakila.actor);
set @last_week := CuRRENT_DATE-INterval 1 week;
```

然后可以在任何可以使用表达式的地方使用这些自定义变量：

```mysql
select ... where col <= @last_week;
```

在了解自定义变量的强大之前，我们再来看看它自身的一些属性和限制，看看在哪些场景下我们不能使用用户自定义变量：

- 使用自定义变量的查询，无法使用查询缓存。
- 不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名和LIMIT子句中。
- 用户自定义变量的生命周期是在一个连接中有效，所有不能用它们来做连接间的通信。
- 如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。
- 在5.0之前的版本，是大小写敏感的，所以要注意代码在不同MySQL版本间的兼容性问题。
- 不能显示地声明自定义变量的类型。确定未定义变量的具体类型的实际在不同MySQL版本中也可能不一样。如果你希望变量是整数类型，那么最好在初始化的时候就赋值为0，如果希望是浮点型则赋值为0.0，如果希望是字符串则赋值为“”。用户定义变量的类型在赋值的时候会改变。MySQL的用户自定义变量是一个动态的类型。
- MySQL优化器来某些场景下可能会将这些变量优化掉，这可能导致代码不按预想的方式运行。
- 赋值的顺序和赋值的时间点并不总是固定的，这依赖于优化器的决定。实际情况可能让人困惑，后面我们将看到这一点。
- 赋值符号 := 的优先级非常低，所以需要注意，赋值表达式应该使用明确的括号。
- 使用未定义变量不会产生任何语法错误，如果没有意识到这一点，非常容易犯错。

#### 优化排名语句

使用用户自定义变量的一个重要特性是你可以在给一个变量赋值的同时使用这个变量。换句话说，用户自定义变量的赋值具有“左值”特性。下面的例子展示了如何使用变量来实现一个类似“行号”的功能：

<img src="images/image-20210327090137933.png" alt="image-20210327090137933" style="zoom:50%;" />

这个例子的实际意义并不大，它只是实现了一个和该表主键一样的列。不过，我们也可以把这当作一个排名。现在我们来看一个更复杂的用法。我们先编写一个查询获取演过最多电影的前10位演员，然后根据它们的出现电影次数做一个排名，如果出演的电影数量，则排名相同。我们先编写一个查询，返回每个演员参演电影的数量：

```mysql
select actor_id, count(*) as cnt
from sakila.film_actor
group by actor_id
order by cnt desc
limit 10;
```

<img src="images/image-20210327090411605.png" alt="image-20210327090411605" style="zoom:50%;" />

现在我们再把排名加上去，这里看到有四名演员都参演了35部电影，所以他们的排名应该是相同的。我们使用三个变量来是实现：一个用来记录当前的排名，一个用来记录前一个演员的排名，还有一个用来记录当前演员参演的电影数量。只有当前演员参演的电影的数量和前一个演员不同时，排名才变化。我们先试试下面的写法：

<img src="images/image-20210327091001960.png" alt="image-20210327091001960" style="zoom:50%;" />

Oops---排名和统计列一直都无法更新，这是什么原因？

对这类问题，是没法给出一个准确的答案的，例如一个拼写错误，具体问题要具体分析。这里，通过explain我们看到将会使用临时表和文件排序，所以可能是由于变量赋值的时间和我们预料的不同。

在使用用户自定义变量的时候，经常会遇到一些“诡异”的现象，要揪出这些问题的原因通常都不容易，但是相比其带来的好处，深究这些问题是值得的。使用SQL语句生成排名通常需要做两次计算，例如，需要额外计算一次出现过相同数量电影的演员有哪些。使用变量则可一次完成--这对性能是一个很大的提升。

针对这个案例，另一个简单的方案是在FROM子句中使用子查询生成一个中间的临时表：

<img src="images/image-20210327091704913.png" alt="image-20210327091704913" style="zoom:50%;" />

#### 避免重复查询刚刚更新的数据

如果在更新行的同时又希望获得该行的信息，要怎么做才能避免重复的查询呢？不幸的是，MySQL并不支持像PostgreSQL那样的Update returning语法，这个语法可以帮你在更新行的时候同时返回该行的信息。还好在MySQL中你可以使用变量来解决这个问题。例如，我们的一个客户希望能够更高效地更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么。简单地，可以用下面的代码来实现：

```mysql
update t1 set lastUpdated = now where id = 1;
select lastUpdated from t1 where id =1;
```

使用变量，我们可以按如下方式重写查询：

```mysql
update t1 set lastUpdated = now() where id = 1 and @now := now()
select @now;
```

上面看起来仍然需要两个查询，需要两次网络来回，但是这里的第二个查询无须访问任何数据表，所以会快很多。（如果网络延迟非常大，那么这个优化的意义可能不大，不过对这个客户，这样做对效果很好。）

#### 统计更新和插入的数量

当使用了insert on duplicate key update的时候，如果想知道到底插入了多少行数据，到底有多少数据是因为冲突而改写成更新操作的？Kerstion Konhntopp在他的博客上给出了一个解决这个问题的办法。实现办法的本质如下：

```mysql
insert into tc(c1,c2)values(4,4,),(2,1),(3,1)
on duplicate key update 
 	c1 = values(c1) + (0 * (@x := @x + 1))
```

当每次由于冲突导致更新时对变量@x自增一次。然后通过对这个表达式乘0来让其不影响要更新的内容。另外，MYsQL的协议会返回被更改的总行数，所以不需要单独统计这个值。

#### 确定取值的顺序

使用用户自定义变量的一个最常见的问题就是没有注意到在赋值和读取变量的时候才可能是在查询到不同阶段。例如，在select子句中进行赋值然后在where子句中读取变量，则可能变量取值并不如你所想。下面的查询看起来只返回一个结果，但事实并非如此：

<img src="images/image-20210327093052248.png" alt="image-20210327093052248" style="zoom:50%;" />

因为where和select是在查询执行的不同阶段被执行的。如果在查询中在加入order by 的话，结果可能会更不同：

![image-20210327093147384](images/image-20210327093147384.png)

这是因为order by 引入了文件排序，而where条件是在文件排序操作之前取值的，所以这条查询会返回表中的全部记录。解决这个问题的办法是让变量的赋值和取值发生在执行查询的同一阶段：

<img src="images/image-20210327093335852.png" alt="image-20210327093335852" style="zoom:50%;" />

小测试：如果在上面的查询中再加上order by ，那么会返回什么结果呢？试试看吧。如果得出的结果出乎你的意料，详细为什么？再看下面这个查询会返回什么，下面的查询中order by 子句会改变变量值，那where语句执行时变量值是什么。

<img src="images/image-20210327093529742.png" alt="image-20210327093529742" style="zoom:50%;" />

这个最出任意料的变量行为的答案可以在explain语句中找到，注意看在extra列中的Using where 、Using temporary或者Using filesort。

在上面的最后一个例子中，我们引入了一个新的技巧：我们将赋值语句放到Least()函数中，这样就可以完全不改变排序的时候完成赋值操作（在上面例子中，Least()函数总是返回0）。这个技巧在不希望对子句的执行结果又影响却又要完成变量赋值的时候很有用。在这个例子中，无须返回值中新增额外列。这样的函数还有GREATEST（) 、length（）、InNULL（）、NULLIFL（）、iF（）和COALESCE（），可以单独使用也可以组合使用。例如，COALESCE（）可以在一组参数重取第一个已经被定义的变量。

#### 编写偷懒的UNION

假设需要编写一个UNION查询，其第一个子查询作为分支条件先执行，如果找到了匹配的行，则跳过第二个分支。在某些业务场景中确实会有这样的需求。比如先在一个频繁访问的表中查找“热”数据，找不到再去另外一个饿较少访问的表中查找“冷”数据。

下面的查询会在两个地方查找一个用户--一个主用户表、一个长时间不活跃的用户表，不活跃用户表的目的是为了实现更高效的归档：

> Baron认为在一些社交网站上归档一些常见不活跃用户后，用户重新回到网站时有这样的需求，当用户再次登陆时，一方面我们需要将其从归档中重新拿出来，另外，还可以给他发送一份欢迎邮件。这对一些不活跃的用户是非常好的一个优化。在11章中我们呢还会再次讨论这个问题。

<img src="images/image-20210328195758988.png" alt="image-20210328195758988" style="zoom:50%;" />

上面这个查询是可以正常工作的，但是即使在users表中已经找到了记录，上面的查询还是会归档表中再查找一次。我们可以用一个偷懒的UNION查询来抑制这样的数据返回，而且只有当第一个表中没有数据时，我们才在第二个表中查询。一旦在第一个表中找到记录，我们就定义一个变量@found。我们通过在结果列中做一次赋值来实现，然后将赋值放在函数GRETEST中来避免返回额外的数据。为了明确我们的结果到底来值哪个表，我们新增了一个包含表名的列。最后我们需要在查询的末尾将变量重置为NULL，这样保证遍历时不干扰后面的结果。完整的查询如下：

<img src="images/image-20210328200030618.png" alt="image-20210328200030618" style="zoom:50%;" />

#### 用户定义变量的其他用处

不仅是在SELECT语句中，在其他任何类型的SQL语句中都可以对变量进行赋值。事实上，这也是用户自定义变量最大的用途。例如，可以像前面使用子查询的方式改进排名语句一样来改进UPDATE语句。

不过，我们需要使用一些技巧来获得我们希望的结果。有时，优化器会把变量当作一个编译时常量来对待，而不是对其进行赋值。将函数放在类似于LEAST（）这样的函数通常可以避免这样的问题。另一个办法是在查询被执行前检查变量是否被赋值。不同的场景下使用不同的办法。

通过一些时间，可以了解用户自定义变量能够做的有趣的事情，例如下面这些用法：

- 查询运行时计算总数和平均值。

- 模拟GROUP语句中的函数FIRST（） 和LAST（）

- 对大量数据做一些数据计算。

- 计算一个大表的MD5散列值。

- 编写一个样本处理函数，当样本中的数值超过边界时的时候将其变成0.

- 模拟读/写游标

- 在SHOW语句的WHERE子句中加入变量值。

  ![image-20210328200619066](images/image-20210328200619066.png)

## 6.8 案例学习

通常，我们要做的不是查询优化，不是库表结构优化，不是索引优化也不是应用设计优化--在时间中可能要面对所有这些搅合在一起的情况。本节的案例奖为大家介绍一些经常困扰用户的问题和解决办法。另外我们还推荐BIll Karwin的书SQLAntipatterns（一本实践型的书籍）。它将介绍如何使用SQL解决各种程序员疑难杂症。

### 6.8.1 使用MySQL构建一个队列表

使用MySQL来实现队列是一个取巧的做法，我们看到很多系统在高流量、高并发的情况下表现并不好。典型的模式是一个表包含多种类型的记录：未处理记录、已处理记录、正在处理记录等。一个或者多个消费线程在表中查找未处理的记录，然后声称正在处理，当处理完成后，再将记录更新成已处理状态。一般的，例如邮件发送、多命令处理、评论修改等会使用类似模式。

通常有两个问题使得大家认为这样的处理方式并不合适。第一，随着队列表越来越大和索引深度的增加，找到未处理记录的速度会随之变慢。你可以通过队列分成两部分这个问题，就是将已处理记录归档或者存放到历史表，这可以使中保证队列表很小。

第二，一般的处理过程分为两部，先找到未处理记录然后加锁。找到记录会增加服务器的压力，而加锁操作则会让各个消费进程增加竞争，因为这是一个串行化的操作。在第11章，我们会看到这为什么会限制可扩展性。

找到未处理记录一般来说都没问题，如果有问题则可以通过使用消息的方式来通知各个消费者。具体的，可以使用一个带有注释的SLEEP（）函数做超时处理，如下：

select sleep(10000);

这让线程一直阻塞，直到两个条件之一满足：10000秒后超时，或者另一个线程使用KILL QUERY结束当前的SLEEP。因此，当再向队列表中新增一批数据后，可以通过SHOW PROCESSLIST ,根据注释找到当前正在休眠的线程，并将其KILL。你可以使用函数GET_LOCK()和RELEASE_LOCK（）来实现通知，或者可以在数据库之外实现，例如使用一个消息服务。

>  这里的我看不懂了，就不摘抄了。
>
> 251-257 没有摘抄。



## 6.9 总结

如果把创建高性能应用程序比做是一个环环相扣的“难题”，除了前面介绍的schema、索引和查询语句设计之外，查询优化应该是解开”难题“的最后一步了。要想写一个好的查询，你必须理解schema设计、索引设计等，反之亦然。

理解查询是如何被执行的以及时间都消耗在哪些地方，这亦然是前面我们介绍的响应时间的一部分。再加上一些诸如解析和优化过程的知识，就可以更进一步地理解上一章讨论的MySQl如何访问表和索引的内容。这也从另一个维度帮助读者理解MySQL在访问表和索引时查询和索引的关系。

优化通常都需要三管齐下：不做、少做、快速地做。我们希望这里的案例能够帮助你将理论和实践练习起来。

除了这些基础的手段，包括查询、表结构、索引等，MySQL还有一些高级的特性可以帮助你优化应用，例如分区，分区和索引有些类似但是原理不同。MySQl还支持查询缓存，它可以帮你缓存查询结果，当完全相同的查询再次执行时，直接使用缓存结果。我们将在下一章中介绍这些特性。

