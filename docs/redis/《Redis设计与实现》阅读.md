# 开始读redis 设计与实现

前言，作者为了编写用户关系模块，用于计算两个用户关注哪些相同的用户，传统的关系型数据库并不直接支持交集计算操作，需要先合并，并且去重，不是很好处理。然后作者想到是否存在直接支持集合操作的数据库，带着该疑问，发现了redis。

Redis 内置了集合数据类型，并支持对集合执行交集、并集、差集等集合操作。

然后有一些问题需要被了解：

- Redis的五种数据类型分别是由什么数据结构实现的？
- Redis的字符串数据类型既可以存储字符串，又可以存储证书和浮点数，甚至二进制位，Redis在内部是怎样存储这些值的？
- Redis的一部分命令只能对特定数据类型执行，而另一部分命令却可以对所有数据类型执行，不同命令在执行时是如何进行类型检查的？Redis在内部是否实现了一个类型系统？
- Redis的数据库是怎样存储各种不同数据类型的键值对的？数据库里的过期键又是如何实现自动删除的？
- 除了数据库之外，Redis还拥有发布与订阅、脚本、事物等特性，这些特性又是如何实现的？
- Redis使用什么模型或者模式来处理客户端的命令请求？一条命令请求从发送到返回需要经过什么步骤？



>  我应该首先会去看第一部分和第二部分的内容，然后看第四部分的内容，慢慢看吧～

## 第一部分 数据结构与对象

### 1.简单动态字符串

​	Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串(simple dynamic string, sds)的抽象类型，并将sds用作Redisc的默认字符串表示。

​	在Redis里面，C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志：	

​	 redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye...")；

​	当Redis需要的不仅仅是以个字符串字面量，而是以个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。

​	举个例子，如果客户端执行命令：

​	redis> set msg "hello world"

​	ok

​	那么redis将在数据库中创建一个新的键值对，其中：

- 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的sds。

- 键值对的值也是以个字符串对象，对象的底层实现是以个保存着字符串"hello world"的sds。

  又比如，如果客户端执行命令：

  redis> rpush fruits "apple" "banana" "cherry"

  (integer) 3

那么Redis将在数据库中创建一个新的键值对，其中：

- 键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串“fruits”的sds。
- 键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着字符串“apple”，第二个SDS保存着字符串“banana”，第三个SDS保存着字符串“cherry”。

除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区(buffer):aof 模块中的aof缓冲区，以及客户端状态中的输入缓冲区，都是由sds实现的，在之后介绍aof持久化和客户端状态的时候，我们会看到sds在这两个模块中的应用。

- 保存数据库中的字符串值 
- 缓冲区
  - AOF缓冲区
  - 客户端状态的输入缓冲区

#### 1.1 SDS的定义

```
struct sdshdr {
	int len;
	int free;
	char buf[];
}
```



#### 1.2 sds与C字符串的区别

##### 1.2.1 常数复杂度获取字符串长度

- STRLEN命令的复杂度为O(1)
- 设置和更新SDS长度的工作是由SDS的APi在执行时自动完成的。

##### 1.2.2杜绝缓冲区溢出

​			其空间分配策略完全杜绝了发生缓存溢出的可能性：当SDSAPI需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的需求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需要的大小，然后才执行修改操作

##### 1.2.3 减少修改字符串时带来的内存重分配次数

​			为了避免C字符串这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。

​	通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

**空间预分配**

用于优化SDS的字符串增长操作： 会分配额外空间

- 如果对SDS修改后，SDS的长度小于1MB，那么分配的free = len，总长度为 2 * len + 1
- 如果对SDS修改后，SDS的长度大于等于1MB，那么分配的free = 1MB ，总长度为 len + 1MB + 1

通过空间预分配，Redis可以减少连续执行字符串增长操作所需的内存重新分配次数。

在扩展SDS空间之前，SDS APi会先检查未使用的空间是否足够，如果足够的话，API就会直接使用未使用空间，无须执行内存重分配。

通过这种预分配策略，SDS将连续增长N次字符串所需的内存重新分配次数从必定N次降低为最多N次。



##### 1.2.4 二进制安全

##### 1.2.5 兼容部分C字符串函数

##### 1.2.6 总结

#### 1.3 SDS API 



