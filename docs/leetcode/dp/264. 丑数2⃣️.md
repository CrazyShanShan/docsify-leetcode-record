# 264. 丑数2⃣️

URL：https://leetcode-cn.com/problems/ugly-number-ii/

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 

示例 1：

输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
示例 2：

输入：n = 1
输出：1
解释：1 通常被视为丑数。


提示：

1 <= n <= 1690

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/ugly-number-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

2021年 5月 6日 星期四 16时50分07秒 CST 

这里直接参考三叶姐的解法： https://leetcode-cn.com/problems/ugly-number-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-3nvs/

在heap中，给出了普通解法，在这里是DP专题，因此给出DP方法。

从普通解法中不难发现，我们【往后产生的丑数】都是基于【已有丑数】而来（使用【已有丑数】乘上【质因数】2、3、5）。

因此，如果我们所有丑数的有序序列为a1,a2,a3,...,an的话，序列中的每一个数都必然能够被以下三个序列（中的至少一个）覆盖：

- 由丑数* 2所得的有序序列：1 * 2、 2 * 2、 3 * 2、 4 * 2、 5 * 2、 6 * 2、 8 * 2...
- 由丑数* 3所得的有序序列： 1 * 3、 2 * 3、 3 * 3、 4 * 3、 5 * 3、 6 * 3、8 * 3...
- 由丑数* 5 所得的有序序列：1 * 5、 2 * 5、 3 * 5、 4 * 5、 5 * 5、 6 * 5、 8 * 5...

假设我们需要求得【1，2，3..., 10，12】丑数序列arr的最后一位，那么该序列可以看作以下三个有序序列归并而来：

- 1 * 2 、 2* 2、3*2..., 10 * 2, 12 * 2，将2提出，即arr * 2
- ... 将3提出，即 arr * 3
- ... 将5提出，即 arr * 5

因此我们可以使用三个指针来指向目标序列arr的某个下标（下标0作为哨兵不使用，起始都为1），使用arr[下标]* 质因数 代表当前使用三个有序序列中的哪一位，同时使用idx表示当前生产到arr哪一位丑数。

dp[i]=min(dp[p_2]*2,dp[p_3]*3,dp[p_5]*5)

```java
class Solution {
	public int nthUglyNumber(int n) {
    // ans 用作存储已有丑数（从下标1开始存储，第一个丑数为1）
    int[] ans = new int [n + 1];
    ans[1] = 1;
    // 由于三个有序序列都是由【已有丑数】*【质因数】而来
    // i2 i3 i5分别代表三个有序序列当前使用到哪一位【已有丑数】下标（起始都指向1）
    for (int i2 = 1, i3 = 1, i5 = 1, idx = 2; idx <= n; idx++) {
      // 由ans[iX] * X 可得当前有序序列指向哪一位
      int a= ans[i2] * 2, b = ans[i3] * 3, c = ans[i5] * 5;
      // 将三个有序序列中的最小一位存入【已有丑数】序列，并将其下标后移
      int min = Math.min(a, Math.min(b, c));
      if (min == a) i2++;
      if (min == b) i3++;
      if (min == c) i5++;
      ans[idx] = min;
    }
    return ans[n];
  }
}
```



