# 53. 最大子序和

URL：https://leetcode-cn.com/problems/maximum-subarray/

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [0]
输出：0
示例 4：

输入：nums = [-1]
输出：-1
示例 5：

输入：nums = [-100000]
输出：-100000


提示：

1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105


进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

对于本题来说，可以采用暴力法、分治法、动态规划法、贪心法。

同理，这里是动态规划专题，还是只考虑动态规划的算法。

要求：返回给定数组nums，找到其   具有最大和的连续子数组。

对于每个点来说，其都有以该点为结尾点的最大和连续子数组。(可能就为这个数本身，同时也可能为这个数加上前面的最大和的连续子数组。)

因此可以定义状态： dp[i] = max (dp[i - 1] + A[i], A[i])

```java
class Solution {
    public int maxSubArray(int[] A) {
        int n = A.length;
        int[] f = new int[n];
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                f[i] = A[i];
                res = Math.max(res, f[i]);
                continue;
            }
            f[i] = Math.max(A[i], f[i-1] + A[i]);
            res = Math.max(res, f[i]);
        }
        return res;
    }
}
```

很简单的可以写出具有空间复杂度为O（N） 的算法，由于每一个元素只与上一个元素相关，因此可以进行空间优化。

```java
class Solution {
    public int maxSubArray(int[] A) {
        int n = A.length;
        int[] f = new int[2];
        int res = Integer.MIN_VALUE;
        int old = 1, now = 0;
        for (int i = 0; i < n; i++) {
            old = now;
            now = 1 - now;
            if (i == 0) {
                f[now] = A[i];
                res = Math.max(res, f[now]);
                continue;
            }
            f[now] = Math.max(A[i], f[old] + A[i]);
            res = Math.max(res, f[now]);
        }
        return res;
    }
}
```

