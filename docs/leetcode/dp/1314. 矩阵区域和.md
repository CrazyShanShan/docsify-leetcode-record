# 1314. 矩阵区域和

URL： https://leetcode-cn.com/problems/matrix-block-sum/

给你一个 m * n 的矩阵 mat 和一个整数 K ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： 

i - K <= r <= i + K, j - K <= c <= j + K 
(r, c) 在矩阵内。


示例 1：

输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 1
输出：[[12,21,16],[27,45,33],[24,39,28]]
示例 2：

输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 2
输出：[[45,45,45],[45,45,45],[45,45,45]]


提示：

m == mat.length
n == mat[i].length
1 <= m, n, K <= 100
1 <= mat[i][j] <= 100

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/matrix-block-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

解题思路
开始没有什么思路，然后看了一眼官方题解，说需要取补充前缀数组的知识，让我移步去1292题，所以我就看了1292的题，然后看了1292题的官方解答，在官方解答中介绍了关于二维前缀数组的知识。
按照我的理解，什么是前缀数组：

前缀数组的作用: 快速计算二维矩阵中，某一个矩形中所有元素的和。（互斥原理）
可以定义一个数组P【m】【n】，P【x】【y】表示矩形的左上角【0】【0】，到右下角【x-1】【y-1】的和
其中 x 属于（0， m-1） y属于（0， n - 1）
在定义了前缀和数组P【】【】以后，我们就可以快速地计算二维数组中某个矩形的所有元素和了：
假设 矩形的左上角的坐标为【x1】【y1】，右下角的坐标为【x2】【y2】，那么矩形的元素和为：
Sum = P【x2】【y2】 - P【x1 - 1】【y2】 - P 【x2】【y1 - 1】 + P【x1 - 1】【y1 - 1】；
这里我简单的画一个图：我的图真的不干恭维呀（UBUNTU，用的截图工具画的，各位大佬有好的截图工具给我推一推,(>_<)）

那么应该如何取计算二维前缀和数组呢： 同意使用互斥原理
P[i][j] = P[i - 1] [j] + P[i][j - 1] - P[i - 1] [j - 1] + mat[i - 1] [j - 1];
到这里，就可以开始去解本题了：

首先计算前缀和数组，可以多开一个数据行大小，可以避免去判断等于0的问题。
P[i][j] = P[i - 1] [j] + P[i] [j - 1] - P[i - 1] [j - 1] + mat[i - 1] [j - 1];
开始计算返回值的结果：
计算矩形左上角和右下角的值(x1,y1),(x2,y2)
tips: 1. 这里需要注意的问题是：需要去判断边界值的问题，使用三元表达式来缩减行数

2. 初学的小伙伴可能会对于坐标的映射，不能立刻确定（我也是，慢慢确定就好了啦）
x1 = i - k + 1 > 1 ? i - k + 1 : 1;
y1 = j - k + 1 > 1 ? j - k + 1 : 1;
x2 = i + k + 1 < m ? i + k + 1 : m;
y2 = j + k + 1 < n ? j + k + 1 : n;

通过公式来计算矩形区域和的大小
res[i][j] = P[x2] [y2] - P[x1 - 1] [y2] - P[x2] [y1 - 1] + P[x1 - 1] [y1 - 1];
到这里，题目就解完啦。
下面来看看时间和空间复杂度：

时间复杂度 O（mn）:两次遍历矩形
空间复杂度 O（mn）: 保存前缀和数组P[m][n]
代码

```java
class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        // 先求矩阵的前缀和数组
        int m = mat.length;
        int n = mat[0].length;
        int[][] P = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }
        int[][] res = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int x1, y1 ,x2, y2;
                x1 = i - k + 1 > 1 ? i - k + 1 : 1;
                y1 = j - k + 1 > 1 ? j - k + 1 : 1;
                x2 = i + k + 1 < m ? i + k + 1 : m;
                y2 = j + k + 1 < n ? j + k + 1 : n;
                res[i][j] = P[x2][y2] - P[x1 - 1][y2] - P[x2][y1 - 1] + P[x1 - 1][y1 - 1];
            }
        }
        return res;
    }
}


```



作者：crazyshanshan
链接：https://leetcode-cn.com/problems/matrix-block-sum/solution/qian-zhui-shu-zu-4ms-9631-by-crazyshansh-7uaq/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。