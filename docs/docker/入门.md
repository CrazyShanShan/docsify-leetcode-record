# 入门

## 1. 下载并安装docker

直接brew 安装就好， 安装的直接就是docker desktop，其中包含了docker。

## 2. 开始教程

docker run - d - p 80 : 80 docker/getting-started

-d : 以分离模式运行容器（在后台）

-p : 将主机的80端口映射到容器中的80端口

docker/getting-started ： 要使用的图像

## 3. 什么是容器？

容器只是你机器上的另一个进程，与主机上的所有其他进程隔离开来。 隔离利用了内核命名空间和cgroups。

## 4. 什么是容器镜像？

运行容器时，它使用隔离的文件系统。此自定义文件系统由 **容器映像提供。** 由于镜像包含容器的文件系统，它必须包含运行应用程序所需的一切--所有依赖项、配置、脚本、二进制文件等。镜像还包含容器的其他配置，例如环境变量、要运行的默认命令、和其他元数据。

## 5.  镜像体系结构

镜像的最底层是一个启动文件系统（bootfs）镜像，bootfs 的上层镜像叫做根镜像，一般来说，根镜像是一个操作系统，例如 Ubuntu、CentOS 等，用户的镜像必须构建于根镜像之上，在根镜像之上，用户可以构建出各种各样的其他镜像。
从上面的介绍读者可以看出，镜像的本质其实就是一系列文件的集合，一层套一层的结构有点类似于 Git ，也有点类似于生活中的洋葱

## 6. 镜像的写时复制机制

通过 `docker run` 命令指定一个容器创建镜像时，实际上是在该镜像之上创建一个空的可读写的文件系统层级，可以将这个文件系统层级当成一个临时的镜像来对待，而命令中所指的模版镜像则可以称之为父镜像。父镜像的内容都是以只读的方式挂载进来的，容器会读取共享父镜像的内容，用户所做的所有修改都是在文件系统中，不会对父镜像造成任何影响。当然用户可以通过其他一些手段使修改持久化到父镜像中，这个我们后面会详细介绍到。

简而言之，镜像就是一个固定的不会变化的模版文件，容器是根据这个模版创建出来的，容器会在模版的基础上做一些修改，这些修改本身并不会影响到模版，我们还可以根据模版（镜像）创建出来更多的容器。

如果有必要，我们是可以修改模版（镜像）的。

## 7. 镜像查看

用户可以通过 `docker images` 命令查看本地所有镜像，如下：

这里一共有五个参数，含义分别如下：

- TAG: TAG用于区分同一仓库中的不同镜像，默认为latest
- IMAGE ID: IMAGE ID是镜像的一个唯一标识符。
- CREATED: CREATED表示镜像的创建时间。
- SIZE: SIZE表示镜像的大小。
- REPOSITORY:仓库名称，仓库一般用来存放同一类型的镜像。仓库的名称由其创建者指定。如果没有指定则为 `<none>` 。一般来说，仓库名称有如下几种不同的形式:
  - `[hub.c.163.com/library/nginx]`:这种指定 url 路径的方式，一般用于非 Docker Hub 上的镜像命名，例如一个第三方服务商提供的镜像或者开发者自己搭建的镜像中心，都可以使用这种命名方式命名。
  - `[ubuntu]`:这种只有仓库名，对于这种没有命名空间的仓库名，可以认为其属于顶级命名空间，该空间的仓库只用于官方的镜像，由 Docker 官方进行管理，但一般会授权给第三方进行开发维护。当然用户自己创建的镜像也可以使用这种命名方式，但是将无法上传到 Docker Hub 上共享。
  - `[namespace\ubuntu]`:这种仓库名称由命名空间和实际的仓库名组成，中间通过 `\` 隔开。当开发者在 Docker Hub 上创建一个用户时，用户名就是默认的命名空间，这个命令空间是用来区分 Docker Hub 上注册的不同用户或者组织（类似于 GitHub 上用户名的作用），如果读者想将自己的镜像上传到 Docker Hub 上供别人使用，则必须指定命名空间，否则上传会失败。

## 8. 镜像下载

当用户执行 `docker run` 命令时，就会自动去 Docker Hub 上下载相关的镜像，这个就不再重复演示，开发者也可以通过 search 命令去 Docker Hub 上搜索符合要求的镜像，如下：

其中：

- NAME：表示镜像的名称。
- DESCRIPTION：表示镜像的简要描述。
- STARS：表示用户对镜像的评分，评分越高越可以放心使用。
- OFFICIAL：是否为官方镜像。
- AUTOMATED：是否使用了自动构建。

在执行 `docker run` 命令时再去下载，速度会有点慢，如果希望该命令能够快速执行，可以在执行之前，先利用 `docker pull` 命令将镜像先下载下来，然后再运行。



### 9. 镜像删除

镜像可以通过 `docker rmi` 命令进行删除，参数为镜像的id或者镜像名，参数可以有多个，多个参数之间用空格隔开。如下：

有的时候，无法删除一个镜像，大部分原因是因为该镜像被一个容器所依赖，此时需要先删除容器，然后就可以删除镜像了，删除容器的命令可以参考本系列前面的文章。



## 10. 创建镜像

而父镜像并未受影响，如果读者需要根据这种修改创建一个新的本地镜像，有两种不同的方式，先来看第一种方式：commit。

### 创建容器

首先，根据本地镜像运行一个容器，如下：

命令解释：

1. 首先执行 docker images 命令，查看本地镜像。
2. 根据本地镜像中的 nginx 镜像，创建一个名为 nginx 的容器，并启动。
3. 将宿主机中一个名为 index.html 的文件拷贝到容器中。
4. 访问容器，发现改变已经生效。
5. 接下来再重新创建一个容器，名为 nginx2。
6. 访问 nginx2 ，发现 nginx2 中默认的页面还是 nginx 的默认页面，并未发生改变。

### commit创建本地镜像

接下来，根据刚刚创建的第一个容器，创建一个本地镜像，如下：

命令解释：

1. 参数 -m 是对创建的该镜像的一个简单描述。
2. --author 表示该镜像的作者。
3. ce1fe32739402 表示创建镜像所依据的容器的 id。
4. sang/nginx 则表示仓库名，sang 是名称空间，nginx 是镜像名。
5. v1 表示仓库的 tag。
6. 创建完成后，通过 docker images 命令就可以查看到刚刚创建的镜像。
7. 通过刚刚创建的镜像运行一个容器，访问该容器，发现 nginx 默认的首页已经发生改变。
8. 这是我们通过 commint 方式创建本地镜像的方式，但是 commit 方式存在一些问题，比如不够透明化，无法重复，体积较大，为了解决这些问题，可以考虑使用 Dockerfile ，实际上，主流方案也是 Dockerfile。

### Dockfile

Dockerfile 就是一个普通的文本文件，其内包含了一条条的指令，每一条指令都会构建一层。先来看一个简单的例子。

首先在一个空白目录下创建一个名为 Dockerfile 的文件，内容如下：

命令解释：

1. FROM nginx 表示该镜像的构建，以已有的 nginx 镜像为基础，在该镜像的基础上构建。
2. MAINTAINER 指令用来声明创建镜像的作者信息以及邮箱信息，这个命令不是必须的。
3. RUN 指令用来修改镜像，算是使用比较频繁的一个指令了，该指令可以用来安装程序、安装库以及配置应用程序等，一个 RUN 指令执行会在当前镜像的基础上创建一个新的镜像层，接下来的指令将在这个新的镜像层上执行，RUN 语句有两种不同的形式：shell 格式和 exec 格式。本案例采用的 shell 格式，shell 格式就像 linux 命令一样，exec 格式则是一个 JSON 数组，将命令放到数组中即可。在使用 RUN 命令时，适当的时候可以将多个 RUN 命令合并成一个，这样可以避免在创建镜像时创建过多的层。
4. COPY 语句则是将镜像上下文中的 `hello.html` 文件拷贝到镜像中

命令解释：

1. -t 参数用来指定镜像的命名空间，仓库名以及 TAG 等信息。
2. 最后面的 `.` 是指镜像构建上下文。