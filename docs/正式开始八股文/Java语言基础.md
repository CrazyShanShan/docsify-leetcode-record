# Java语言基础

## 语法基础

### 面向对象大三特性

- **封装：** 封装是指把属性和方法的实现细节进行隐藏，对属性的访问必须通过公共接口。
- **继承：** 用来扩展一个类，提高代码的复用性，即子类可以继承父类的成员变量和成员方法
- **多态：** 以封装和继承为基础，即运行同一行为作用在不同的对象，具有不同的表现形式

继承在Java中是单一继承，子类只能继承父类的非私有成员变量和方法。

子类对象时绝对大于父类对象的，所谓子类对象只能继承父类非私有的属性及方法的观点是错误的。可以继承，只是无法访问到而已。

### 多态的实现原理

- 多态是指在 **编译层面无法确定最终调用的方法体**， 在运行期由JVM动态绑定，调用合适的重写方法。
  - 由于重载属于静态绑定，本质上 重载结果是完全不同的方法，因此多态一般指的是重写。

**编译时多态：重载**

- 同一个类有多个同名的方法，但是这些方法有着不同的参数，在编译时期就可以确定到底调用哪个方法。

**运行时多态： 重写**

- 子类重写父类的方法，父类的引用变量不仅可以指向父类的实例对象，同时可以指向子类的实例对象。当父类的引用指向子类的对象时，只要在运行时才能确定调用了哪个方法。

### static 

- 修饰类： 静态内部类
- 修饰方法：
  - 静态成员方法属于类，不需要创建对象就可以使用，静态方法里边只能访问所属类的静态成员变量和静态成员方法
- 修饰成员变量那个：
  - 静态变量属于类，只要静态变量所在的类被加载，静态变量就会被分配内存，并且在内存中只有一份，所有的对象共享静态变量
  - 注明： **不能在方法体中定义静态变量**
- 修饰代码块
  - 静态代码块经常用来 **初始化静态变量**， 在类加载的初始化阶段会执行为静态变量赋值的语句和静态代码块的内容，静态代码块只执行一次

### **final/finally/finalize**

**final:**

- 修饰类： 该类不能被继承，类中的方法默认被final修饰
- 修饰方法： 该方法不能被子类重写
- 修饰变量：
  - 基本数据类型的变量：表示该值在被初始化后不能更改。必须初始化
  - 引用类型： 表示该引用在初始化后不能再指向其他对象。必须初始化

**为什么使用final?**

- 锁定方法，防止任何继承类修改它的实现
- **高效，** 当被一个final修饰的方法，直接讲方法主题插入到调用处，而不进行方法调用

**String类为什么被设计为final类型**

- **字符串常量池的需要**
- **hashCode缓存的需要，因为字符串是不可辨的，因此创建的时候hashCode就被缓存**
- **线程安全：因为同一个字符串可以被多个线程共享，不需要使用线程安全问题而被同步，字符串自己便是线程安全的。**
- **为了防止扩展类无意间破坏了原来方法的实现。**

**finally**

- finally 是一场处理的一部分

**finalize**

- 是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize()方法







### 重写override/ 重载overload

**重载**

- 指的是方法名相同，但是参数类型不同（不同参数类型，不同参数个数，不同参数顺序）。对于编译器来说，方法名称和参数列表组成了一个唯一键，称为方法签名，JVM通过方法签名决定调用哪种方法，属于静态绑定。

**重写**

- 指的是实现接口或者继承父类时，保持方法签名完全相同，实现不同的方法体。元空间有一个方法表保存信息，如果子类重写了父类的方法，则方法表中的方法引用会指向子类实现。

**重写与多态**

非静态方法前面其实有一个默认的对象this，this在构造起他表示正在创建的对象。

因为正在创建的是子类，所以重写的方法执行的是子类重写的代码。

**不可以重写的方法**

- final方法
- 静态static方法
- private等子类中不可见方法，如果重写private方法，相当于是新定义的方法。

**对象的多态性**

- 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
- 非静态方法默认的调用对象是this
- this对象在构造器方法中就是正在创建的对象

### 接口和抽象类

**区别**

- 抽象类是对类的 **整体抽象**， 包括属性和行为的抽象，接口只是对行为的抽象。
- 抽象类实现的是继承的关系，父类和派生类之间是 “is -a ”关系，即父类和派生类本质上应该是相同的。
- 接口类体现的是“has - a”关系，实现它的子类可以不存在任何关系。

| 语法     | 抽象类                                             | 接口                                                         |
| -------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 成员变量 | 无特殊要求                                         | 默认是public static final                                    |
| 构造方法 | 有构造方法，**不能被实例化**                       | 没有构造方法                                                 |
| 方法     | 抽象类可以没有抽象方法，但是有抽象方法一定是抽象类 | 默认是public abstract，jdk8支持默认/静态方法，jdk9支持私有方法 |
| 继承     | 单继承                                             | 多继承                                                       |



### 内部类

根据定义的方式的不同可以分为：

- 静态内部类
- 非静态内部类
- 局部内部类
- 匿名内部类

**静态内部类和非静态内部类**

1. 静态内部类不依赖于外部类实例而实例化，非静态内部类需要在外部类实例化后才能被实例化
2. 静态内部类不需要持有外部类的引用，非静态内部类需要持有外部类的引用
3. 静态内部类只能访问外部类的静态成员和静态方法，非静态内部类可以访问外部的静态/非静态成员方法

```java
public class OuterClass {
  
  private static String staticMas = "static Msg";
  
  private String msg = "msg";
  
  // 静态内部类
  public static class NestedStatic {
     // 静态内部类只能访问外部类的静态成员和方啊
    	public void print() {
        	sout(msg); // 这里会编译报错
        	sout(staticMas);
      }
  }
  
  // 非静态内部类 
  public class InnerClass {
     // 非静态内部类可以访问（静态或者非静态的属性和方法）	
      	public void print() {
        	sout(msg); // 这里会编译报错
        	sout(staticMas);
      }
  }
  
  public class Main {
    	psvm() {
        // 创建静态内部类 
        OuterClass.NestedStaticClass s = new OuterClass.NestedStaticClass();
         
        // 创建非静态内部类需要外部类的实例
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.new InnerClass();
        
      }
  }
  
  
}
```

**局部内部类**

1. 在外部类的方法中定义的类，其作用范围是所在的方法内，不能被public private protected修饰
2. 只能访问方法中定义为final类的局部变量

```java
class OuterClass {
	public void fun() {
		// 局部内部类
		class InnerClass {
		
		}
	}
}
```

**匿名内部类**

1. 匿名内部类是在new的后面， **且必须继承一个父类或者实现一个接口，不能有构造函数**
2. 只能创建匿名内部类的一个实例

```java
interface Person {
	public abstact void eat();
}
  public class Main {
    	psvm() {
				Person p = new Person() {
					@Ovveride
					public void eat() {
						sout("eat");
					}
				};
        p.eat();
      }
  }

```



### 强制类型转换

- 当小于int的数据类型（byte/char/short）进行运算时，首先会把这些类型的变量值强制转为int类型，对int类型的值进行计算，最后得到的值也是int类型的。因此如果把2个short类型的值相加，得到的结果是int类型的。

  - ```java
    short s1 = 1; s1 = s1 + 1;// 报错
    short s1 = 1; s1 = (short)(s1 + 1);
    short s1 = 1; s1 += 1;
    
    ```

- 基本数据类型和boolean不能相互转换

- char类型的数据转为高级数据类型时，会转换为对应的ACSII码



### 异常分类与处理

<img src="../pictures/java异常分类.png" alt="image-20210816115558060" style="zoom:50%;" />

- 异常是指程序运行时发生的错误。

- Error
  - 表示程序在运行期间发生了非常严重的错误，并且该错误是不可恢复的。Error不需要捕捉，如OutofMemoryError
- Exception
  - 可恢复的异常。包括2种类型，检查异常和运行时异常
  - **Check Exception 受检异常（编译阶段）**
    - IOException
    - SQLException
    - FIleNotFoundException
  - RuntimeException **非受检异常（运行阶段，编译器不会检查运行时异常）**





## Java反射机制

