## [164. 最大间距](https://leetcode-cn.com/problems/maximum-gap/)

**补充：**

```
本题写了基数排序以及还有桶排序
```

  

**analyse:**

```
本题非常困难，建议去看y总的题解。
采用的是桶排序、抽屉原理，同时对桶中的元素做了一个限定。
记录了桶中的最大元素和最小元素。
最终得到的结果是，当桶的长度为len时，可以使得，桶内任意两个元素的差不可能是本题的结果。
计算的结果为： len = (max - min + n - 2) / (n - 1)
然后扫描一遍这个桶。
```

**code:**

```java
class Solution {
    
    class Range {
        int min;
        int max;
        boolean used;
        public Range() {
            min = Integer.MAX_VALUE;
            max = Integer.MIN_VALUE;
            used = false;
        }
    }
    
    public int maximumGap(int[] nums) {
        int n = nums.length;
        int MIN = Integer.MAX_VALUE;
        int MAX = Integer.MIN_VALUE;
        for (int num: nums) {
            MIN = Math.min(MIN, num);
            MAX = Math.max(MAX, num);
        }
        if (n < 2 || MIN == MAX) return 0;
        Range[] r = new Range[n - 1];
        for (int i = 0; i < n - 1; i++) r[i] = new Range();
        int len = (MAX - MIN + n - 2) / (n - 1);
        for (int num: nums) {
            if (num == MIN) continue;
            int k = (num - MIN - 1) / len;
            r[k].used = true;
            r[k].min = Math.min(r[k].min, num);
            r[k].max = Math.max(r[k].max, num);
        }
        int res = 0;
        for (int i = 0, last = MIN; i < n - 1; i++) {
            if (r[i].used) {
                res = Math.max(res, r[i].min - last);
                last = r[i].max;
            }
        }
        
        return res;
    }
}
```



**同时在这里补充一下：关于基数排序的知识**

基数排序适用于将数组最大间距（长度）比较小，但是数个数很多的情况，时间复杂度为O (k(n + radis)

```
补充一下：
[78, 56, 89, 45, 23, 12, 79, 46, 13]
统计cnt之后可以得到：
[0, 0, 1, 2, 0, 1, 2, 0, 1, 2]
经过本轮排序可以得到：
[12, 23, 13, 45, 46, 56, 78, 79, 89]
那么如何去把相应的元素放到相应的地方去呢？
这里就采用了后缀数组。cnt[n] = cnt[n - 1]
[0, 0, 1, 3, 3, 4, 6, 6, 7, 9]
得到了每个基数在数组中的最右的位置。然后需要cnt[k]--。
```



这里欣赏一下官方的解答：

```java
class Solution {
    public int maximumGap(int[] nums) {
        int n = nums.length;
        if (n < 2) {		
            return 0;
        }
        long exp = 1;
        int[] buf = new int[n];
        int maxVal = Arrays.stream(nums).max().getAsInt();

        while (maxVal >= exp) {
            int[] cnt = new int[10];
            for (int i = 0; i < n; i++) {
                int digit = (nums[i] / (int) exp) % 10;
                cnt[digit]++;
            }
            for (int i = 1; i < 10; i++) {
                cnt[i] += cnt[i - 1];
            }
            for (int i = n - 1; i >= 0; i--) {
                int digit = (nums[i] / (int) exp) % 10;
                buf[cnt[digit] - 1] = nums[i];
                cnt[digit]--;
            }
            System.arraycopy(buf, 0, nums, 0, n);
            exp *= 10;
        }

        int ret = 0;
        for (int i = 1; i < n; i++) {
            ret = Math.max(ret, nums[i] - nums[i - 1]);
        }
        return ret;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/maximum-gap/solution/zui-da-jian-ju-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

