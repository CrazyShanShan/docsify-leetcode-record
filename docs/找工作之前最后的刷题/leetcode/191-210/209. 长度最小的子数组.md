## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

**analyse:**

```
首先考虑 暴力： 枚举【i, j]，求和算满足条件的最小值
优化， 考虑单调性，单调性可以使用双指针来去掉一位。
枚举右端点j, 找到一个最靠右的端点i,使得[i, j] >= s
如果i' > i, 那么j' > j
对于i'来说，至少要去到j。

方法一： 双指针
方法二： 前缀数组 + 二分
```

**code:**

**方法一： 双指针**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int res = Integer.MAX_VALUE;
        for (int i = 0, j = 0, sum = 0; i < nums.length; i++) {
            sum += nums[i];
            while (sum - nums[j] >= target) sum -= nums[j++];
            if (sum >= target) res = Math.min(res, i - j + 1);
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
```

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        res = len(nums) + 1
        j = 0
        sum = 0
        for i in range(n):
            sum += nums[i]
            while sum - nums[j] >= target:
                sum -= nums[j]
                j += 1
            if sum >= target:
                res = min(res, i - j + 1)
        return res if res != n + 1 else 0;
```



**方法二：**前缀数组 + 二分得到左端点

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        s = [0] * (n + 1)
        for i in range(1, n + 1):
            s[i] = s[i - 1] + nums[i - 1]
        res = n + 1
        for i in range(1, n + 1):
            if s[i] >= target:
                left = 1
                right = i
                while left < right:
                    mid = left + right + 1 >> 1
                    if (s[i] - s[mid - 1]) >= target:
                        left = mid
                    else:
                        right = mid - 1
                res = min(res, i - right + 1)
        return res if res != n + 1 else 0
```

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int[] s = new int[n + 1];       
        for (int i = 1; i <= n; i++) {
            s[i] = s[i - 1] + nums[i - 1];
        }
        int res = Integer.MAX_VALUE;
        for (int i = 1; i <= n; i++) {
            if (s[i] >= target) {
                int left = 1, right = i;
                while (left < right) {
                    int mid = left + right + 1 >> 1;
                    if ((s[i] - s[mid - 1]) >= target) left = mid;
                    else right = mid - 1;
                }
                res = Math.min(res, i - right + 1);
            }
        }
        return res != Integer.MAX_VALUE ? res : 0;
    }
}
```

