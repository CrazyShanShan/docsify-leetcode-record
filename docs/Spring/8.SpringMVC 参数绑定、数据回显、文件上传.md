# SpringMVC 参数绑定、数据回显、文件上传

URL： https://mp.weixin.qq.com/s?__biz=MzI4Njg5%C3%A5MDA5NA==&mid=2247484008&idx=2&sn=44e15b795eda5e1f112bf663cc146bf7&chksm=ebd74369dca0ca7fedadb2835d80896df76fa5279a9db38abccceb2b25c9ee95d549cc9010ed&scene=178&cur_album_id=1344014214528335873#rd

## 前言：

本文讲解的知识点为：

- 参数绑定
- 数据回显
- 文件上传

## 参数绑定

在Controller使用方法参数接受值，就是把Web端的值给接收到Controller重处理，这个过程就叫做 **参数绑定**

### 默认支持的参数类型

从上面的用法我们可以发现，我们使用request对象、Model对象等，是不是可以随便把参数写上去都行？其实并不是这样。

Controller方法支持的参数类型有4个，这4个足以支持我们日常开发。

- HttpServletRequest
- HttpServletResponse
- HttpSession
- Model

### 参数的绑定过程

**一般的，我们要用到自定义的参数绑定就是上面所讲的日期类型以及一些特殊的需求。。。** 对于平时的参数绑定，我们是无需使用转换器的。

SpringMVC就已经帮我们干了这个活了。

<img src="pic/SpringMVC 参数绑定.png" alt="image-20210812145022266" style="zoom:50%;" />

#### 自定义绑定参数【老方式、全部Action均可使用】

在上一篇已经简单较少了怎么把字符串转换成日期类型了【使用的是WebDataBinder方式】。其实是一种比较老的方法，我们可以使用SpringMVC更推荐的方式。

在上次把字符串转成日期类型，如果使用的WebDataBinder方式的话，那么该转换仅仅只能在当前Controller使用。如果想要全部的Controller都能够使用，那么，我们可以使用 **WebBIndingInitializer方式**

**如果想要多个controller需要共同注册相同的属性编辑器，可以实现PropertyEditorRegistry接口，并注入WebBindingInitializer中。**

1. 实现接口

```java
public class CustomPropertyEditor implements PropertyEditorRegistrar {

    @Override
    public void registerCustomEditors(PropertyEditorRegistry binder) {
        binder.registerCustomEditor(Date.class, new CustomDateEditor(
                new SimpleDateFormat("yyyy-MM-dd HH-mm-ss"), true));

    }

}
```

2. 配置转换器

注入到webBindingInitializer中

```
    <!-- 注册属性编辑器 -->
    <bean id="customPropertyEditor" class="cn.itcast.ssm.controller.propertyeditor.CustomPropertyEditor"></bean>


    <!-- 自定义webBinder -->
    <bean id="customBinder"
        class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer">

        <!-- propertyEditorRegistrars用于属性编辑器 -->
         <property name="propertyEditorRegistrars">
            <list>
                <ref bean="customPropertyEditor" />
            </list>
        </property>
    </bean>


    <!-- 注解适配器 -->
    <bean
        class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
        <!-- 在webBindingInitializer中注入自定义属性编辑器、自定义转换器 -->
        <property name="webBindingInitializer" ref="customBinder"></property>
    </bean>
```

#### 自定义参数转换器【新方式、推崇方式】 

上面的方式是对象较老的，现在我们一般都是 **实现Converter接口来实现自定义参数转换** 

1. 配置日期转换器

```java
public class CustomDateConverter implements Converter<String, Date> {

    @Override
    public Date convert(String source) {
        try {
            //进行日期转换
            return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(source);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

}
```

2. 配置去除字符串转换器

```java
public class StringTrimConverter implements Converter<String, String> {

    @Override
    public String convert(String source) {
        try {
            //去掉字符串两边空格，如果去除后为空设置为null
            if(source!=null){
                source = source.trim();
                if(source.equals("")){
                    return null;
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        return source;
    }
}
```

从上面可以得出，我们想要转换什么内容，就直接实现接口，该接口又是支持泛型的，阅读起来就非常方便了。

3. 配置转换器

```xml
  <!-- 转换器 -->
    <bean id="conversionService"
          class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
        <property name="converters">
            <list>
                <bean class="cn.itcast.ssm.controller.converter.CustomDateConverter"/>
                <bean class="cn.itcast.ssm.controller.converter.StringTrimConverter"/>
            </list>
        </property>
    </bean>


    <!-- 自定义webBinder -->
    <bean id="customBinder"
        class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer">
        <!-- 使用converter进行参数转 -->
        <property name="conversionService" ref="conversionService" />
    </bean>


    <!-- 注解适配器 -->
    <bean
        class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
        <!-- 在webBindingInitializer中注入自定义属性编辑器、自定义转换器 -->
        <property name="webBindingInitializer" ref="customBinder"></property>
    </bean>
```

如果是基于 <mvc:annotaion-driven>的话，我们是这样配置的

```xml
<mvc:annotation-driven conversion-service="conversionService">
</mvc:annotation-driven>
<!-- conversionService -->
    <bean id="conversionService"
        class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
        <!-- 转换器 -->
        <property name="converters">
            <list>
                <bean class="cn.itcast.ssm.controller.converter.CustomDateConverter"/>
                <bean class="cn.itcast.ssm.controller.converter.StringTrimConverter"/>
            </list>
        </property>
    </bean>

```

#### @Request 注解

我们一般使用的参数绑定都有遵循的规则：  **方法参数名要与传递过来的name属性名相同。**

在默认情况下，只有名字相同，SpringMVC才会帮我们进行参数绑定

如果我们要使用 **@RequestParam注解**的话，我们就可以使方法参数名与传过来的name属性名不同

该注解有三个变量

- value ： 指定name属性的名称是什么
- required ：是否必要有该参数
- defaultvalue : 设置默认值

例子: 

```java
public String editItem(@RequestParam(value="item_id", required = true) String id);
```



## Controller方法返回值

Controller方法的返回值其实就几种类型，我们来总结一下：

- void
- String
- ModelAndView
- redirect 重定向
- forward转发

### 数据回显

在SpringMVC中，我们是 **使用Model来把数据绑定到request域对象中的**

一般我们是使用model.addAtrribute()的方式把数据绑定到request域对象中。。。

### @ModelAttribute注解

可以将请求的参数放到Model中，回现到页面上

和model.addAttribute()的方式是没啥区别的，体现不了注解的方便性

而如果我们要回显的数据是公共的话，那么我们就能够体会到注解的方便性了，我们 **把公共需要显示的属性抽取成方法，将返回值返回就行了**

````java
// 单独将商品类型的方法提出来，将方法返回值填充到request，在页面显示
@ModelAttribute("itemsType")
public Map<String, String> getItemsType() {
	Map<String, String> itemsType = new HashMap<>();
	itemsType.put("001", "数码");
	return itemsType;
	}
````

那我们就不用在每一个controller方法通过Model将数据传到页面。



## SpringMVC文件上传

### 配置虚拟目录

这次，我们并不把图片上传到我们的工程目录中。

**工程目录是我们写代码的地方，往往需要备份我们的工程目录。**

如果把图片都上传到工程目录，那么就非常难以处理图片了。

因此， **我们需要配置Tomcat的虚拟目录来解决，把上传的文件放在虚拟目录上。**

**这里我没有去查spring mvc的配置， Springboot的虚拟目录配置方法为：**

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    //
    // @Override
    // public void addResourceHandlers(ResourceHandlerRegistry registry) {
    //     // 资源配置
    //     registry.addResourceHandler("swagger-ui.html")
    //             .addResourceLocations("classpath:/META-INF/resources/");
    //     // registry.addResourceHandler("/webjars/**")
    //     //         .addResourceLocations("classpath:/META-INF/resources/webjars/");
    // }
}
```

```
具体的地址可以放在配置文件中：
   @Value("${qiniu.accessKey}")
    private  String accessKey;
    @Value("${qiniu.accessSecretKey}")
    private  String accessSecretKey;
通过这种方式进行下载    

```

### 文件上传

```java

@Controller
public class FirstUploadController {
    @RequestMapping("firstUploadController")
    public String doFirst(@RequestParam("uploadFile") MultipartFile uploadFile, HttpSession session) throws IllegalStateException, IOException {
        String filename = uploadFile.getOriginalFilename();
        
        String leftPath = session.getServletContext().getRealPath("/image");
        System.out.println(leftPath);
        File file = new File(leftPath, filename);
      	
      // 上传文件
        uploadFile.transferTo(file);
      
        return "index";
        
    }
}
```

## SpringBoot 自定义转换器

摘抄URL： https://blog.csdn.net/weixin_43931625/article/details/107279831

应用： 实现一对一转换，如将字符串转换为pojo，枚举等等。

1. 定义Converter

```java
@FunctionalInterface
public interface Converter<S,T> {
	@Nullable
	T convert(S source); //将类型S的对象转换成类型为T的对象
}
```

2. 定义ConverterFactory

```
public interface ConverFactory<S, R> [
	<T extends R> Converter<S, T> getConverter(Class<T> targetType);
]
```

3. 部分内置 converter、converterFactory

EnumToStringConverter: **将枚举字面量转换为字符串**

```java
final class EnumToStringConverter extends AbstractConditionalEnumConverter implements Converter<Enum<?>, String> {
 
	public EnumToStringConverter(ConversionService conversionService) {
		super(conversionService);
	}
 
	@Override
	public String convert(Enum<?> source) {
		return source.name();
	}
 
}

```

StringToNumerConverterFactory: 字符串转换数字

```java

final class StringToNumberConverterFactory implements ConverterFactory<String, Number> {
 
	@Override
	public <T extends Number> Converter<String, T> getConverter(Class<T> targetType) {
		return new StringToNumber<>(targetType);
	}
 
 
	private static final class StringToNumber<T extends Number> implements Converter<String, T> {
 
		private final Class<T> targetType;
 
		public StringToNumber(Class<T> targetType) {
			this.targetType = targetType;
		}
 
		@Override
		public T convert(String source) {
			if (source.isEmpty()) {
				return null;
			}
			return NumberUtils.parseNumber(source, this.targetType);
		}
	}
 
}
```



自定义 ： 枚举对象属性转换



```java
public enum Sex {
 
    Male(1,"男"),Female(2,"女");
 
    private Integer id;
    private String name;
 
    Sex(Integer id,String name){
        this.id=id;
        this.name=name;
    }
 
    public Integer getId() {
        return id;
    }
 
    public void setId(Integer id) {
        this.id = id;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    @Override
    public String toString() {
        return "Sex{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
```



```java
@Data
public class Person {
 
    private String name;
    private Integer age;
    private Sex sex;
}
```



```java
@Component
public class StringToEnumConverter implements Converter<String, Sex> {
 
    @Override
    public Sex convert(String source) {
        Sex sex=Sex.Male;
        if ("女".equals(source)){
            sex=Sex.Female;
        }
 
        return sex;
    }
}

```

```java
@Component
public class WebConfig implements WebMvcConfigurer {
 
    @Resource
    private StringToEnumConverter stringToEnumConverter;
 
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(stringToEnumConverter);
    }
}
```

